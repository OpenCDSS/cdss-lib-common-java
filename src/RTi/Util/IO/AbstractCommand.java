// AbstractCommand - this class can be used as a parent class for other commands.

/* NoticeStart

CDSS Common Java Library
CDSS Common Java Library is a part of Colorado's Decision Support Systems (CDSS)
Copyright (C) 1994-2025 Colorado Department of Natural Resources

CDSS Common Java Library is free software:  you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

CDSS Common Java Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

You should have received a copy of the GNU General Public License
    along with CDSS Common Java Library.  If not, see <https://www.gnu.org/licenses/>.

NoticeEnd */

package RTi.Util.IO;

import javax.swing.JFrame;	// For the editor.

import RTi.Util.Message.Message;

/**
This class can be used as a parent class for other commands.
It contains data members and access methods that commonly are used and do not need to be implemented in specific command classes.
Note that the derived class should implement the Command interface methods - its
implementation here will be insufficient for most needs (e.g., editing).
*/
public abstract
class AbstractCommand extends Object implements Command, CommandStatusProvider, CommandProcessorEventProvider
{

/**
The full command string for the command, as specified during initialization.
This is initialized to blank.
It can include spaces at the beginning for indentation.
*/
private String commandString = "";

/**
 * Number of spaces as indentation at the beginning of the command string.
 * The default is 4 spaces per indent level.
 */
protected int indentSpaceCount = 0;  // Use protected for commands like TSID.

/**
The command name only, as taken from the command string.
This is initialized to blank;
*/
private String commandName = "";

/**
The command processor, which will run the command and be associated with the command GUI.
*/
private CommandProcessor processor = null;

/**
Array of CommandProcessorEventListeners.
*/
private CommandProcessorEventListener [] CommandProcessorEventListener_array = null;

/**
Array of CommandProgressListeners.
*/
private CommandProgressListener [] CommandProgressListener_array = null;

/**
The command parameters, determined from processing the command string.
This is initialized to an empty PropList and should be set when initializing the command.
*/
private PropList parameters = new PropList ( "" );

/**
The status for the command.
*/
private CommandStatus status = new CommandStatus();

/**
Whether or not the command is a plugin.
*/
private boolean isPlugin = false;

// TODO SAM 2016-03-23 Evaluate whether command profile should be null and only instantiated based
// on a processor property, in order to save memory.
/**
The runtime profile for the command.
Although designed to have a profile for each command phase, focus on the run phase for now.
*/
private CommandProfile profile = new CommandProfile();

/**
Default constructor for a command.
*/
public AbstractCommand () {
}

/**
Add a CommandProcessorEventListener.
@param listener a CommandProcessorEventListener, to handle events generated by this command.
*/
public void addCommandProcessorEventListener ( CommandProcessorEventListener listener ) {
    // Use arrays to make a little simpler than Vectors to use later.
    if ( listener == null ) {
        return;
    }
    // See if the listener has already been added.
    // Resize the listener array.
    int size = 0;
    if ( this.CommandProcessorEventListener_array != null ) {
        size = this.CommandProcessorEventListener_array.length;
    }
    for ( int i = 0; i < size; i++ ) {
        if ( this.CommandProcessorEventListener_array[i] == listener ) {
            return;
        }
    }
    if ( this.CommandProcessorEventListener_array == null ) {
        this.CommandProcessorEventListener_array = new CommandProcessorEventListener[1];
        this.CommandProcessorEventListener_array[0] = listener;
    }
    else {
        // Need to resize and transfer the list.
        size = this.CommandProcessorEventListener_array.length;
        CommandProcessorEventListener [] newlisteners = new CommandProcessorEventListener[size + 1];
        for ( int i = 0; i < size; i++ ) {
                newlisteners[i] = this.CommandProcessorEventListener_array[i];
        }
        this.CommandProcessorEventListener_array = newlisteners;
        this.CommandProcessorEventListener_array[size] = listener;
        newlisteners = null;
    }
}

/**
Add a CommandProgressListener.
@param listener a CommandProgressListener, to handle events generated by this command.
*/
public void addCommandProgressListener ( CommandProgressListener listener ) {
    // Use arrays to make a little simpler than lists to use later.
    if ( listener == null ) {
        return;
    }
    // See if the listener has already been added.
    // Resize the listener array.
    int size = 0;
    if ( this.CommandProgressListener_array != null ) {
        size = this.CommandProgressListener_array.length;
    }
    for ( int i = 0; i < size; i++ ) {
        if ( this.CommandProgressListener_array[i] == listener ) {
            return;
        }
    }
    if ( this.CommandProgressListener_array == null ) {
    	this.CommandProgressListener_array = new CommandProgressListener[1];
    	this.CommandProgressListener_array[0] = listener;
    }
    else {
        // Need to resize and transfer the list.
        size = this.CommandProgressListener_array.length;
        CommandProgressListener [] newlisteners = new CommandProgressListener[size + 1];
        for ( int i = 0; i < size; i++ ) {
            newlisteners[i] = this.CommandProgressListener_array[i];
        }
        this.CommandProgressListener_array = newlisteners;
        this.CommandProgressListener_array[size] = listener;
        newlisteners = null;
    }
}

/**
Check the command parameter for valid values, combination, etc.
This should normally be implemented in the derived class.
@param parameters The parameters for the command.
@param commandTag an indicator to be used when printing messages, to allow a cross-reference to the original commands.
@param warningLevel The warning level to use when printing parse warnings
(recommended is 2 for initialization, and 1 for interactive command editor dialogs).
*/
public void checkCommandParameters ( PropList parameters, String commandTag, int warningLevel )
throws InvalidCommandParameterException {
}

/**
Clone the instance.  All command data are cloned except for the following,
which use the same references as the original object:  CommandProcessor.
*/
public Object clone () {
	try {
        AbstractCommand command = (AbstractCommand)super.clone();
		// _command_string and _command_name are automatically cloned
		// Processor is not cloned, use a reference to the same processor.
		command.processor = this.processor;
		// Clone the status.
		command.status = (CommandStatus)this.status.clone();
		// Clone the parameters.
		// Do this the brute force way for now using string properties but later need to evaluate,
		// especially if full objects are used for parameters.
		// TODO SAM 2007-09-02 Need full clone() on PropList.
		PropList props = new PropList ( "" );
		int size = command.parameters.size();
		Prop prop = null;
		for ( int i = 0; i < size; i++ ) {
			prop = command.parameters.elementAt(i);
			if ( prop == null ) {
				// Should not happen.
			}
			else {
				props.set ( prop.getKey(), prop.getValue() );
			}
		}
		command.parameters = props;
		return command;
	}
	catch ( CloneNotSupportedException e ) {
		// Should not happen because everything is cloneable.
		throw new InternalError();
	}
}

/**
Edit a command instance.
The instance may be a newly created command or one that has been created previously and is now being re-edited.
@return the Command instance that is created and edited, or null if the edit was canceled.
@param parent Parent JFrame on which the model command editor dialog will be shown.
*/
public boolean editCommand ( JFrame parent ) {
	// Use the generic command editor.
	return (new GenericCommand_JDialog ( parent, this )).ok();
}

/**
Edit a new command.
@return the Command instance that is created and edited, or null if the edit was canceled.
@param parent Parent JFrame on which the model command editor dialog will be shown.
*/
/* TODO SAM 2005-04-29 need to figure out a graceful way to do this.
CommandFactory?
public static Command editNewCommand ( JFrame parent ) {
	Command c = new Command();
	if ( c.editCommand(parent).ok() ) {
		return c;
	}
	else {	return null;
	}
}
*/

/**
Return the command name, from the command string.
@return the command name, from the command string.
*/
public String getCommandName () {
	return this.commandName;
}

/**
Return the parameters being used by the command.
The Prop.getHowSet() method can be used to determine whether a property was defined in the original command string
(Prop.SET_FROM_PERSISTENT) or is defaulted internally (Prop.SET_AS_RUNTIME_DEFAULT).
TODO SAM 2005-04-29 Does this need a boolean parameter to allow dialogs to see only the parameters in the command,
so that defaults are not explicitly displayed?
@return the parameters being used by the command.  A non-null list is guaranteed.
*/
public PropList getCommandParameters () {
	return this.parameters;
}

/**
Return the command processor that is managing the command.
@return the CommandProcessor used to process the command.
*/
public CommandProcessor getCommandProcessor () {
	return this.processor;
}

/**
Return the command profile for the requested phase.  Currently a profile is only implemented for the run phase.
@param phase the command phase (currently only CommandPhaseType.RUN is supported)
@return the command profile (null if other than CommandPhaseType.RUN is requested)
*/
public CommandProfile getCommandProfile ( CommandPhaseType phase ) {
    if ( phase == CommandPhaseType.RUN ) {
        return this.profile;
    }
    return null;
}

/**
Return the status for the command.
The version provided in this abstract version returns UNKNOWN for the status.
Commands that extend from this abstract class should set the status more explicitly.
*/
public CommandStatus getCommandStatus () {
	return this.status;
}

/**
Returns the original command string.
@return the original command string.
*/
public String getCommandString() {
	return this.commandString;
}

/**
 * Indicate whether the command is a plugin command.
 * This will result in different handling of command data.
 */
public boolean getIsCommandPlugin () {
	return this.isPlugin;
}

/**
 * Return the number of indent spaces at the front of the command.
 * This is not yet in the Command interface so use for troubleshooting only because not all commands
 * may extend AbstractCommand.
 */
public int getIndentSpaceCount () {
	return this.indentSpaceCount;
}

/**
 * Return the command indentation spaces, used by toString().
 * @return the command indentation spaces, used by toString()
 */
public String getIndentSpaces() {
	// In-line to increase performance for common indentations:
	// - order by common occurrences, using the default of 4 spaces per indentation level
	if ( this.indentSpaceCount == 4 ) {
		return "    ";
	}
	else if ( this.indentSpaceCount == 8 ) {
		return "        ";
	}
	else if ( this.indentSpaceCount == 12 ) {
		return "            ";
	}
	else if ( this.indentSpaceCount == 16 ) {
		return "                ";
	}
	else if ( this.indentSpaceCount == 1 ) {
		return " ";
	}
	else if ( this.indentSpaceCount == 2 ) {
		return "  ";
	}
	else if ( this.indentSpaceCount == 3 ) {
		return "   ";
	}
	else {
		// Use a builder.
		StringBuilder b = new StringBuilder();
		for ( int i = 0; i < this.indentSpaceCount; i++ ) {
			b.append(" ");
		}
		return b.toString();
	}
}

/**
Initialize the command by parsing the command and indicating warnings.
@param commandString A string command to parse.
This is necessary because the command factory typically only uses a command string to instantiate the proper Command class,
but parameters are not parsed until this method is called.
@param full_initialization If true, the command string will be parsed and checked for errors (by calling parseCommand()).
If false, a blank command will be initialized
(e.g., suitable for creating a new command instance before editing in the command editor).
@exception InvalidCommandSyntaxException if during parsing the command is determined to have invalid syntax.
@exception InvalidCommandParameterException if during parsing the command parameters are determined to be invalid.
*/
public void initializeCommand ( String commandString, CommandProcessor processor, boolean full_initialization )
throws InvalidCommandSyntaxException, InvalidCommandParameterException {
	// Save the processor.
	this.processor = processor;
	// Call the method so that indentation is determined.
	//this.commandString = command;
	setCommandString(commandString);
	if ( full_initialization ) {
		// Parse the command.
		parseCommand ( commandString );
	}
}

// TODO SAM 2005-05-13 Might need to overload this to pass the routine from the derived class,
// and then rely on the standard method.

/**
Notify registered CommandProcessorEventListeners of a CommandProcessorEvent.
@param event event to pass to listeners.
*/
public void notifyCommandProcessorEventListeners ( CommandProcessorEvent event ) {
	if ( this.CommandProcessorEventListener_array != null ) {
	    for ( int i = 0; i < this.CommandProcessorEventListener_array.length; i++ ) {
	        this.CommandProcessorEventListener_array[i].handleCommandProcessorEvent(event);
	    }
	}
}

/**
Notify registered CommandProgressListeners of a CommandProgressEvent.
@param istep The number of steps being executed in a command (0+), for example loop index of objects being processed.
@param nstep The total number of steps to process within a command, for example total number of objects being processed.
@param percentComplete If >= 0, the value can be used to indicate progress running a single command.  If less than zero, then
no estimate is given for the percent complete and calling code can make its own determination
(e.g., ((istep + 1)/nstep)*100).
@param message A short message describing the status (e.g., "Running command ..." ).
*/
public void notifyCommandProgressListeners ( int istep, int nstep, float percentComplete, String message ) {
	if ( this.CommandProgressListener_array != null ) {
	    for ( int i = 0; i < this.CommandProgressListener_array.length; i++ ) {
	        this.CommandProgressListener_array[i].commandProgress(istep, nstep, this, percentComplete, message);
	    }
	}
}

/**
Parse the command string into a PropList of parameters.
The command name will have been set in the constructor for the command.
This method will parse a standard syntax command:
<pre>
commandName(param=value,param="value",param="value(xxx)",...)
</pre>
Custom parsers MUST be implemented for special commands, such as comments and legacy syntax.
Parameter values can contain special characters such as parenthesis but should generally be quoted in these cases.
Command strings can optionally be indented, for example if in an If or For block.
@param commandString A string command to parse.
@exception InvalidCommandSyntaxException if during parsing the command is determined to have invalid syntax.
@exception InvalidCommandParameterException if during parsing the command parameters are determined to be invalid.
*/
public void parseCommand ( String commandString )
throws InvalidCommandSyntaxException, InvalidCommandParameterException {
	String routine = getClass().getSimpleName() + ".parseCommand", message;

	// Determine the indent.
	this.indentSpaceCount = 0;
	for ( int i = 0; i < commandString.length(); i++ ) {
		if ( commandString.charAt(i) == ' ' ) {
			++this.indentSpaceCount;
		}
		else {
			// Done processing initial spaces.
			break;
		}
	}

	// Parse the trimmed command to get the name and parameters.
    // The following causes problems with commands that have quoted parameters that include ().
    // Therefore, parse more brute force to get the command name and parameter list string.
	// List<String> tokens = StringUtil.breakStringList ( command, "()", StringUtil.DELIM_SKIP_BLANKS );
    String commandTrimmed = commandString.trim();
    int parenStart = commandTrimmed.indexOf("(");
    int parenEnd = commandTrimmed.lastIndexOf(")");
	if ( (parenStart <= 0) || (parenEnd != (commandTrimmed.length() - 1)) ) {
		message = "Invalid syntax for \"" + commandString + "\".  Expecting CommandName(parameter=value,...)";
		Message.printWarning ( 2, routine, message);
		throw new InvalidCommandSyntaxException ( message );
	}
    if ( parenEnd != (commandTrimmed.length() - 1) ) {
        message = "Invalid syntax for \"" + commandTrimmed + "\".  Expecting CommandName(parameter=value,...)";
        Message.printWarning ( 2, routine, message);
        throw new InvalidCommandSyntaxException ( message );
    }
	// Get the parameter list.
	String parameterString = commandTrimmed.substring((parenStart + 1), parenEnd);
	if ( parameterString.length() > 0 ) {
		// Parameters are available to parse.
		try {
		    this.parameters = PropList.parse ( Prop.SET_FROM_PERSISTENT, parameterString, routine,"," );
		}
		catch ( Exception e ) {
			message = "Syntax error in \"" + commandTrimmed + "\".  Not enough tokens.";
			Message.printWarning ( 2, routine, message);
			throw new InvalidCommandSyntaxException ( message );
		}
	}
}

/**
Run the command.
@param commandNumber The command number from the processor (0+), used to cross-reference the log to command instances.
@exception CommandWarningException Thrown if non-fatal warnings occur (the command could produce some results).
@exception CommandException Thrown if fatal warnings occur (the command could not produce output).
*/
public void runCommand ( int commandNumber )
throws InvalidCommandParameterException, CommandWarningException, CommandException, InterruptedException {
	// Does nothing.
}

/**
Set the command name, as taken from the command string.
@param commandName The command name.
*/
public void setCommandName ( String commandName ) {
	this.commandName = commandName;
}

/**
Set a command parameter.  This is used, for example, by a command editor dialog,
and results in command parameter PropList being updated and the command string being regenerated.
@param parameter Name of parameter to set.
@param value Value of parameter to set.
Passing a value of null will effectively unset the parameter
(null will be returned when retrieving the parameter value, requiring handling).
*/
public void setCommandParameter ( String parameter, String value ) {
	// Handle values with equals with care.
    this.parameters.set ( parameter, value );
	// Refresh the command string.
	this.commandString = toString();
}

/**
Set the command parameters.  This is most often called when the parameters have been parsed.
@param parameters The command parameters as a PropList - only String parameter values are recognized.
*/
public void setCommandParameters ( PropList parameters ) {
	this.parameters = parameters;
	//Refresh the command string.
	this.commandString = toString();
}

/**
Set the command processor.  Normally this is set in the runCommand() method.
@param processor The CommandProcessor used to process the command.
*/
public void setCommandProcessor ( CommandProcessor processor ) {
	this.processor = processor;
}

/**
Set the command profile.
This is used, for example, to track command performance (processing time) and memory usage.
@param phase the command phase (currently only CommandPhaseType.RUN is implemented)
@param profile the command profile
*/
public void setCommandProfile ( CommandPhaseType phase, CommandProfile profile ) {
    if ( phase == CommandPhaseType.RUN ) {
        this.profile = profile;
    }
}

/**
Set the command string.
This is currently used only by the generic command editor and should only be implemented in this AbstractCommand base class.
@param commandString Command string for the command.
*/
public void setCommandString ( String commandString ) {
	this.commandString = commandString;
	// Set the indent count so that spaces can be added in toString() later.
	this.indentSpaceCount = 0;
	for ( int i = 0; i < commandString.length(); i++ ) {
		if ( commandString.charAt(i) == ' ' ) {
			++this.indentSpaceCount;
		}
		else {
			// Done processing initial spaces.
			break;
		}
	}
}

/**
 * Set whether the command is a plugin.
 * This will result in different handling of command data and documentation.
 * @param isPlugin set whether the command is a plugin command
 */
public void setIsCommandPlugin ( boolean isPlugin ) {
	this.isPlugin = isPlugin;
}

/**
Return the command string.  Note that this method is required by the Command interface.
This version can be relied on to satisfy that requirement.
@return the formatted command string.
*/
public String toString() {
	return toString ( this.parameters );
}

/**
Return the command string with the specified parameter string.
This can be called, for example, with "..." or "" for use in the TSTool UI progress messages when a full command string is too long.
The method should be overloaded for commands that do not follow the CommandName( ... ) pattern, such as comments.
@param parameterString the parameter string in the command parentheses ()
@return the formatted command string.
*/
public String toString ( String parameterString ) {
	return this.commandName + "(" + parameterString + ")";
}

/**
Return the command string using the commands parameters and the given order.
Each command should have a default toString() method that calls this method to control parameter order.
@param parameterOrder The list of parameters for the command, in requested output order.
@return the formatted command string.
*/
public String toString(String [] parameterOrder ) {
	return toString ( this.parameters, parameterOrder );
}

/**
Return the command string, formed from the properties.
This is a helper method.
This version can be relied on to satisfy that requirement but in most cases should be overruled.
An attempt is made to determine the property type and double quote only those that need quoting
(Java Number and Boolean classes are not quoted).
The order of the properties is as added to the property list.
Only properties that are non-null and non-blank are added.
@param commandParameters properties to output, such from a command editor.
@param parameterOrder The list of parameters for the command, in requested output order.
@return the formatted command string.
*/
public String toString ( PropList commandParameters, String[] parameterOrder ) {
	if ( commandParameters == null ) {
		// Likely a new empty command.
		return getIndentSpaces() + getCommandName() + "()";
	}

	if ( (parameterOrder == null) || (parameterOrder.length == 0) ) {
		// Parameter order is not specified so return the default order:
		// - call toStringDefault because calling toString(PropList) results in recursion
		return toStringDefault(commandParameters);
	}

	// Create the list of command parameters.
	StringBuilder b = new StringBuilder ();
	String stringValue;
	Object contents;
	boolean doQuote;
	Prop prop;
	for ( int i = 0; i < parameterOrder.length; i++ ) {
		doQuote = true; // Default is to quote.
		prop = commandParameters.getProp(parameterOrder[i]);
		if ( prop == null ) {
			continue;
		}
		stringValue = prop.getValue();
		contents = prop.getContents();
		if ( (contents == null) || (stringValue == null) ) {
			continue;
		}
		if ( (contents instanceof Number) || (contents instanceof Boolean) ) {
			doQuote = false;
		}
		if ( stringValue.length() > 0 ) {
			if ( b.length() > 0 ) {
				b.append ( "," );
			}
			if ( doQuote ) {
				b.append ( parameterOrder[i] + "=\"" + stringValue + "\"" );
			}
			else {
				b.append ( parameterOrder[i] + "=" + stringValue );
			}
		}
	}

	// Return the formatted command of format:
	//    INDENTCommandName(parameter=value,...)
	for ( int i = 0; i < this.indentSpaceCount; i++ ) {
		b.insert(0," ");
	}
	b.insert(this.indentSpaceCount, this.commandName + "(" );
	b.append(")");
	return ( b.toString() );
}

/**
Return the command string, formed from the properties.
Note that this method is required by the Command interface.
This version can be relied on to satisfy that requirement but in most cases should be overruled
because the parameter order is typically non-alphabetical and specific to a command.
An attempt is made to determine the property type and double quote only those that need quoting
(Java Number and Boolean classes are not quoted).
The order of the properties is as added to the property list, which may not be desirable if standard order is expected.
Only properties that are non-null and non-blank are added.
@param commandParameters The list of command parameters for the command.
@return the command string.
*/
public String toString ( PropList commandParameters ) {
	return toStringDefault( commandParameters);
}

/**
This default version is needed to provide a fall-through without recursion.
Return the command string, formed from the properties.
Note that this method is required by the Command interface.
This version can be relied on to satisfy that requirement but in most cases should be overruled
because the parameter order is typically non-alphabetical and specific to a command.
An attempt is made to determine the property type and double quote only those that need quoting
(Java Number and Boolean classes are not quoted).
The order of the properties is as added to the property list, which may not be desirable if standard order is expected.
Only properties that are non-null and non-blank are added.
@param commandParameters The list of command parameters for the command.
@return the command string.
*/
public String toStringDefault ( PropList commandParameters ) {
	if ( commandParameters == null ) {
		// Likely a new empty command.
		return getIndentSpaces() + getCommandName() + "()";
	}

	StringBuffer b = new StringBuffer ();
	String stringValue;
	Object contents;
	boolean doQuote;
	for ( Prop prop: commandParameters.getList() ) {
		doQuote = true; // Default is to quote.
		stringValue = prop.getValue();
		contents = prop.getContents();
		if ( contents == null ) {
			continue;
		}
		if ( (contents instanceof Number) || (contents instanceof Boolean) ) {
			doQuote = false;
		}
		if ( (stringValue != null) && (stringValue.length() > 0) ) {
			if ( b.length() > 0 ) {
				b.append ( "," );
			}
			if ( doQuote ) {
				b.append ( prop.getKey() + "=\"" + stringValue + "\"" );
			}
			else {
				b.append ( prop.getKey() + "=" + stringValue );
			}
		}
	}

	// Return the formatted command of format:
	//    INDENTCommandName(parameter=value,...)
	for ( int i = 0; i < this.indentSpaceCount; i++ ) {
		b.insert(0," ");
	}
	b.insert(this.indentSpaceCount, this.commandName + "(" );
	b.append(")");
	return ( b.toString() );
}

}