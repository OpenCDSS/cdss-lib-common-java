// LicenseManager -- manages reading license files that have encrypted strings in them.

/* NoticeStart

CDSS Common Java Library
CDSS Common Java Library is a part of Colorado's Decision Support Systems (CDSS)
Copyright (C) 1994-2025 Colorado Department of Natural Resources

CDSS Common Java Library is free software:  you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

CDSS Common Java Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

You should have received a copy of the GNU General Public License
    along with CDSS Common Java Library.  If not, see <https://www.gnu.org/licenses/>.

NoticeEnd */

package RTi.Util.IO;

import RTi.Util.Message.Message;
import RTi.Util.String.StringUtil;
import RTi.Util.Time.DateTime;
import RTi.Util.Time.TimeUtil;

/**
Class to handle encryption, decryption, checking and validation of RTi licenses.

The LicenseManager provides a useful separation between applications and the
encryption/decryption routines for two reasons:<ol>
<li>it makes the application programmer's job easier.</li>
<li>it makes the encryption code more modular -- possibly for removal to native
methods or RMI later.</li></ol>

(See the constructors for parameter definitions in regard to the next section)
LicenseManager is most-commonly used in one of two ways:<ol>
<li>To take an application's license information and a license key and see if
    the license key is the proper key for the given application information.
    This can be done by comparing the license key with a generated license
    key, and by checking that the expiration date for a license key has not
    been passed.
<pre>
    LicenseManager lm = new LicenseManager(
        product, licenseOwner, licenseType, licenseCount, licenseExpires,
	licenseKey);
    if (lm.isLicenseValid()) {
        // checks whether the application information encrypts to the same
	// value as the licenseKey
    }
    if (!lm.isLicenseExpired()) {
        // checks whether the license has expired yet or not
    }
</pre>
</li>

<li>To take an application's information and return an encrypted license key.
    This is used in the RTiCipher application to generate license keys for
    clients.
<pre>
    LicenseManager lm = new LicenseManager(
        product, licenseOwner, licenseType, licenseCount, licenseExpires);
    lm.encrypt();
    String licenseKey = lm.getLicenseKey();
</pre>
</li>

<b>Miscellaneous Notes:</b>
With the Blowfish cipher, the length of the encrypted strings is not directly
related to the length of the string from which it was encrypted.

The exact length of the string generated by Blowfish can be calculated by:
<ul>
<li>take the length of the original string and pad it out with spaces until
    it is 8, 16, 24 ... etc characters long.
    (thus, the string "Hello" will be padded to "Hello   ", and the string
    "Colorado State will be padded to "Colorado State  ".  The string 
    "Colorado" will remain the same)</li>
<li>multiply length of the new and padded string by 2</li>
<li>add 2 to this number.  This is the cipher string used by RTi to determine
    the cipher package and encryption seeds.  RTi's licenses have this number
    only at the very beginning of the whole license, so this step can be
    disregarded for those.</li>
</ul>

So the encrypted String's length can be fairly-closely configured through 
trimming the input string to a desired length.
*/

public class LicenseManager {

/**
The count of licensed products.
*/
private String __licenseCount;

/**
When the license expires.  Format is YYYYMMDD.
*/
private String __licenseExpires;

/**
The encrypted license key.
*/
private String __licenseKey;

/**
The owner of the licensed product.
*/
private String __licenseOwner;

/**
The type of license, which indicates how the software is licensed.
*/
private String __licenseType;

/**
The product that is being licensed with a given license key.
*/
private String __product;

/**
Constructor for a LicenseManager that will encrypt the provided information
into a license key, as used by a license key generator.
@param product the product being licensed.
@param licenseOwner the owner of the licensed product.
@param licenseType the type of license.
@param licenseCount the license count.
@param licenseExpires when the license expires, YYYYMMDD.
*/
public LicenseManager(String product, String licenseOwner, String licenseType,
	String licenseCount, String licenseExpires) {
	initialize(product, licenseOwner, licenseType, licenseCount, licenseExpires, null);
}

/**
Constructor for a LicenseManager that can compare the provided encryption
key to the provided information and see if they match.
@param product the product being licensed.
@param licenseOwner the owner of the licensed product.
@param licenseType the type of license.
@param licenseCount the license count.
@param licenseExpires when the license expires, YYYYMMDD.
@param licenseKey the encrypted license key.
*/
public LicenseManager(String product, String licenseOwner, String licenseType,
	String licenseCount, String licenseExpires, String licenseKey) {
	initialize(product, licenseOwner, licenseType, licenseCount, licenseExpires, licenseKey);
}

/**
Encrypts the license info (product, type, count, owner, expires) into a 
license key, stores the value in the object, and returns the value.
<p>
This version of the encrypt() method is used for the encryption of the license key.
@param prefix the two-character prefix that specifies the encryption type.
@return the encrypted license key.
*/
public String encrypt(String prefix) 
throws Exception {
	return encrypt(prefix, true);
}

/**
Encrypts the license info (product, type, count, owner, expires) into a 
license key.  If the overwriteLicenseKey parameter is set to true, then
the generated key is also stored in the object.  The generated license key
is also returned from this procedure.  This procedure is called with a 
parameter of 'false' when the 'isLicenseValid' method is used.
<p>
This version of the encrypt() method is used more for the validation of 
license keys.
@param prefix the two-character prefix that specifies the encryption type.
@param overwriteLicenseKey whether to save the generated license key value in the object.
@return the encrypted license key.
*/
public String encrypt(String prefix, boolean overwriteLicenseKey) 
throws Exception {
	String product = "";
	if (__product.regionMatches(false, 0, "River", 0, 5)) {
		// This takes the two words in the RiverTrak product line
		// names (RiverTrak/Assistant, RiverTrak/Viewer, etc) and
		// takes the first letter of each name and concatenates them.
		// This is done to shorten the length of the encrypted string.
		product = "R" + __product.substring(9, 10);
	} 
	else if (__product.regionMatches(false, 0, "NWSRFS", 0, 6)) {
		product = "NG";
	} 
	else {
		product = "TSTool";
	}

	String license = "";

	Cipher c = new Cipher(prefix);

	product = c.encrypt(product);
 	String licenseType = c.encrypt(__licenseType);
	String licenseCount = c.encrypt(__licenseCount);
	String licenseOwner = c.encrypt(__licenseOwner);
	String licenseExpires = c.encrypt(__licenseExpires);

	license = 
		prefix + "-"
		+ product.substring(2, product.length()) + "-"
		+ licenseType.substring(2, licenseType.length()) + "-"
		+ licenseCount.substring(2, licenseCount.length()) + "-"
		+ licenseExpires.substring(2, licenseExpires.length()) + "-"
		+ licenseOwner.substring(2, licenseOwner.length());

	if (overwriteLicenseKey) {
		__licenseKey = license;
	}
	return license;
}

/**
Get the number of days until the license expires.  A license has expired if the date
specified in the LicenseExpires property is later than the current date.
Note that this is a secondary check.  'isLicenseValid()' should always be
called first to make sure that the license itself is valid before checking
for an expired license.
@return The number of days until the license expires.  If license expires date is today,
the license won't technically expire until tomorrow and zero is returned.  If the license
never expires, return 10000.  If the license is expired, a negative number will be
returned.
*/
public int getDaysToExpiration() {
    // Check special cases.
    if (__licenseExpires.equalsIgnoreCase("Never")) {
        return 10000;
    }

    // Get the current date.
    DateTime now = new DateTime( DateTime.PRECISION_DAY | DateTime.DATE_CURRENT);
    // Need a new DateTime format to parse YYYYMMDD!...
    if (__licenseExpires.length() != 8) {
        return -1;
    }
    
    String expiresString = __licenseExpires.substring(0, 4) + "-"
        + __licenseExpires.substring(4, 6) + "-"
        + __licenseExpires.substring(6, 8);
    Message.printStatus(1, "", "Expires string=\"" + expiresString + "\"");
    DateTime expires = null;
    try {
        expires = DateTime.parse(expiresString);
    }
    catch (Exception e) {
        // Assume bad date format - expired ...
        return -1;
    }
    Message.printStatus(2, "", "Now: " + now + ", license expires: " + expires );
    int now_days = TimeUtil.absoluteDay(now.getYear(), now.getMonth(), now.getDay() );
    int expires_days = TimeUtil.absoluteDay(expires.getYear(), expires.getMonth(), expires.getDay() );
    return expires_days - now_days;
}

/**
Returns the license count.
@return the license count.
*/
public String getLicenseCount() {
	return __licenseCount;
}

/**
Returns when the license expires.
@return when the license expires.
*/
public String getLicenseExpires() {
	return __licenseExpires;
}

/**
Returns the encrypted license key.
@return the encrypted license key.
*/
public String getLicenseKey() {
	return __licenseKey;
}

/**
Returns the license owner.
@return the license owner.
*/
public String getLicenseOwner() {
	return __licenseOwner;
}

/**
Returns the license type.
@return the license type.
*/
public String getLicenseType() {
	return __licenseType;
}

/**
Returns the product.
@return the product.
*/
public String getProduct() {
	return __product;
}

/**
Initializes the data members of the LicenseManager.  Any of the String values
that are <b>null</b> will be set to an empty string ("").
@param product the product being licensed.
@param licenseOwner the owner of the licensed product.
@param licenseType the type of license.
@param licenseCount the license count.
@param licenseExpires when the license expires.
@param licenseKey the encrypted license key.
*/
private void initialize(String product, String licenseOwner, 
	String licenseType, String licenseCount, String licenseExpires,
	String licenseKey) {
	
	if (product == null) {
		__product = "";
	} 
	else {
		__product = product;
	}
	
	if (licenseOwner == null) {
		__licenseOwner = "";
	} 
	else {
		__licenseOwner = licenseOwner;
	}
	
	if (licenseType == null) {
		__licenseType = "";
	} 
	else {
		__licenseType = licenseType;
	}
	
	if (licenseCount == null) {
		__licenseCount = "";
	} 
	else {
		__licenseCount = licenseCount;
	}
	
	if (licenseExpires == null) {
		__licenseExpires = "";
	} 
	else {
		__licenseExpires = licenseExpires;
	}
	
	if (licenseKey == null) {
		__licenseKey = "";
	} 
	else {
		__licenseKey = licenseKey;
	}
}

/**
Indicate whether the license is a demo license.  This simply checks whether the
string "Demo" is in the license type.
@return true if the license type is a demo license.
*/
public boolean isLicenseDemo() 
{   if ( StringUtil.indexOfIgnoreCase(getLicenseType(),"Demo",0) >= 0 ) {
        return true;
    }
    return false;
}

/**
Determine whether a license is expired.  A license has expired if the date
specified in the LicenseExpires property is later than the current date.
Note that this is a secondary check.  'isLicenseValid()' should always be
called first to make sure that the license itself is valid before checking
for an expired license.
@return true if the licenseExpires date in the license data is after the 
current date.  Returns false if the licenseExpires date is less-than or 
equal-to the current date.  A value of "Never" in licenseExpires will 
result in 'false' being returned.
*/
public boolean isLicenseExpired() {
	// Check special cases.
	if (__licenseExpires.equalsIgnoreCase("Never")) {
		return false;
	}

	// Get the current date.
	DateTime now = new DateTime( DateTime.PRECISION_DAY | DateTime.DATE_CURRENT);
	// Need a new DateTime format to parse YYYYMMDD!...
	if (__licenseExpires.length() != 8) {
		return true;
	}
	
	String expiresString = __licenseExpires.substring(0, 4) + "-"
		+ __licenseExpires.substring(4, 6) + "-"
		+ __licenseExpires.substring(6, 8);
	Message.printStatus(1, "", "Expires string=\"" + expiresString + "\"");
	DateTime expires = null;
	try {
		expires = DateTime.parse(expiresString);
	}
	catch (Exception e) {
		// Assume bad date format - expired ...
		return true;
	}
	Message.printStatus(2, "", "Now: " + now + ", license expires: " + expires);
	if (now.greaterThan(expires)) {
		return true;
	}
	return false;
}

/**
Checks the validity of the license information.  It does this by encrypting
the product, type, count, owner, and expires date into a license key and then
comparing the result to the license key passed in at object creation.  If the
two are the same, then the license is correct.
*/
public boolean isLicenseValid() 
throws Exception {
	if (encrypt(__licenseKey.substring(0, 2), false).equals(__licenseKey)) {
		return true;
	}
	return false;
}

/**
Returns a string with important info from the LicenseManager object.  
For debugging purposes only.

@return a string with important info from the LicenseManager object.
*/
public String toString() {
	return 
		""
		+ "Product:         " + __product 		+ "\n"
		+ "License Owner:   " + __licenseOwner		+ "\n"
		+ "License Type:    " + __licenseType		+ "\n"
		+ "License Count:   " + __licenseCount		+ "\n"
		+ "License Expires: " + __licenseExpires	+ "\n"
		+ "License Key:     " + __licenseKey		+ "\n";
}

}
