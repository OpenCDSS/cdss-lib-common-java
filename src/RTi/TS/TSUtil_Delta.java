// TSUtil_Delta - compute a delta time series containing the delta (difference) between a value and the previous value.

/* NoticeStart

CDSS Common Java Library
CDSS Common Java Library is a part of Colorado's Decision Support Systems (CDSS)
Copyright (C) 1994-2023 Colorado Department of Natural Resources

CDSS Common Java Library is free software:  you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CDSS Common Java Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CDSS Common Java Library.  If not, see <https://www.gnu.org/licenses/>.

NoticeEnd */

package RTi.TS;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.List;

import RTi.Util.Message.Message;
import RTi.Util.String.StringUtil;
import RTi.Util.Table.DataTable;
import RTi.Util.Table.TableField;
import RTi.Util.Table.TableRecord;
import RTi.Util.Time.DateTime;
import RTi.Util.Time.TimeInterval;

/**
Compute a delta time series containing the delta (difference) between a value and the previous value.
*/
public class TSUtil_Delta
{

/**
Input time series to process.
*/
private TS __ts = null;

/**
Analysis start.
*/
private DateTime __analysisStart = null;

/**
Analysis end.
*/
private DateTime __analysisEnd = null;

/**
List of problems generated by this command, guaranteed to be non-null.
*/
private List<String> __problems = new ArrayList<>();

/**
The reset type for the data.
*/
private ResetType __resetType = null;

/**
The trend type expected for the data.
*/
private TrendType __trendType = null;

/**
 * Delta limit value to check.
 */
private Double __deltaLimit = null;

/**
 * Delta limit action ("Keep" or "SetMissing").
 */
private String __deltaLimitAction = null;

/**
 * Delta limit flag.
 */
private String __deltaLimitFlag = null;

/**
 * Interval limit value to check.
 */
private TimeInterval __intervalLimit = null;

/**
 * Interval limit action ("Keep" or "SetMissing").
 */
private String __intervalLimitAction = null;

/**
 * Interval limit flag.
 */
private String __intervalLimitFlag = null;

/**
 * Auto reset datum.
 */
private String __autoResetDatum = null;

/**
 * Auto reset datum as a number.
 */
private Double __autoResetDatumNumber = null;

/**
Reset minimum value.
*/
private Double __resetMin = null;

/**
Reset maximum value.
*/
private Double __resetMax = null;

/**
 * Reset proximity limit.
 */
private Double __resetProximityLimit = null;

/**
 * Reset proximity limit interval.
 */
private TimeInterval __resetProximityInterval = null;

/**
 * Reset proximity limit flag.
 */
private String __resetProximityLimitFlag = null;

/**
Flag to label problem data points.
*/
private String __flag = null;

/**
Indicate whether full time series should be created (true) or empty time series with metadata (false).
*/
private boolean __createData = true;

/**
Table to receive checks.
*/
private DataTable __table = null;

/**
Name of table column for TSID.
*/
private String __tableTSIDColumn = null;

/**
Column number for __tableTSIDColumn.
*/
private int __tableTSIDColumnNum = 4;

/**
Name of table column for date/time.
*/
private String __tableDateTimeColumn = null;

/**
Format of TSID for table TSID column.
*/
private String __tableTSIDFormat = null;

/**
Column number for __tableDateTimeColumn.
*/
private int __tableDateTimeColumnNum = -1;

/**
Name of table column for time series previous value.
*/
private String __tableValuePreviousColumn = null;

/**
Column number for __tableValueColumn.
*/
private int __tableValuePreviousColumnNum = -1;

/**
Name of table column for time series value.
*/
private String __tableValueColumn = null;

/**
Column number for __tableValueColumn.
*/
private int __tableValueColumnNum = -1;

/**
Name of table column for delta calculated value.
*/
private String __tableDeltaCalculatedColumn = null;

/**
Column number for __tableDeltaCalculatedColumn.
*/
private int __tableDeltaCalculatedColumnNum = -1;

/**
Name of table column for action.
*/
private String __tableActionColumn = null;

/**
Column number for __tableActionColumn.
*/
private int __tableActionColumnNum = -1;

/**
Name of table column for delta value after action.
*/
private String __tableDeltaColumn = null;

/**
Column number for __tableDeltaColumn.
*/
private int __tableDeltaColumnNum = -1;

/**
Name of table column for time series flag.
*/
private String __tableFlagColumn = null;

/**
Column number for __tableFlagColumn.
*/
private int __tableFlagColumnNum = -1;

/**
Name of table problem message column for time series flag.
*/
private String __tableProblemColumn = null;

/**
Column number for __tableCheckMessageColumn.
*/
private int __tableProblemColumnNum = -1;

/**
Constructor for Delta calculation,
which will create a new time series where each data value is the change from the previous value.
@param ts time series to process
@param analysisStart the start of processing
@param analysisEnd the end of processing
@param trendType indicates the expected trend, which controls how the resets are handled
@param resetType whether data values are reset, for example roll over when hit a maximum
(currently only ResetType.AUTO and ResetType.RESET_VALUE are supported)
@param autoResetDatum datum for resetType=AUTO, specify as "Auto" or a number (default to 0.0 as number).
@param resetMin the minimum value, to which the data are reset to when the maximum is reached
@param resetMax the maximum value, which is used to compute the delta when a reset occurs
@param resetProximityLimit a cumulative value within resetProximityInterval that result in a problem
@param resetProximityFlag flag used when the resetProximityLimit is exceeded
@param flag flag to label data points that have issues (use "Auto" to use internally determined defaults).
@param createData if true, then perform the full operation, otherwise, just create empty time series
(this is used in discovery operations where only the identifiers need to be intact).
@param deltaLimit value that is the maximum allowed delta value
@param deltaLimitAction action to be performed when value exceeds the delta limit ("Keep" or "SetMissing")
@param deltaLimitFlag flag to use for values that exceed the delta limit (default is no flag set)
@param intervalLimit interval that is the maximum allowed interval between the previous and current values
@param intervalLimitAction action to be performed when value exceeds the interval limit ("Keep" or "SetMissing")
@param intervalLimitFlag flag to use for intervals between values that exceed the interval limit (default is no flag set)
@param table output DataTable - must have been created
@param tableTSIDColumn table column for TSID - will be added if not in the table
@param tableTSIDFormat format to format TSID for match in table, containing % specifiers and ${ts:property}
@param tableDateTimeColumn table column for date/time - will be added if not in the table
@param tableValueColumn table column for check values - will be added if not in the table
@param tableValuePrecision precision for tableValueColumn, or -1 to default
@param tableFlagColumn table column for time series flag corresponding to value - will be added if not in the table
@param tableCheckTypeColumn table column for check type - will be added if not in the table
@param tableCheckMessageColumn table column for check message - will be added if not in the table
*/
public TSUtil_Delta ( TS ts, DateTime analysisStart, DateTime analysisEnd,
    TrendType trendType, ResetType resetType,
    String autoResetDatum,
    Double resetMin, Double resetMax, Double resetProximityLimit, TimeInterval resetProximityInterval, String resetProximityFlag,
    String flag, boolean createData,
    Double deltaLimit, String deltaLimitAction, String deltaLimitFlag,
    TimeInterval intervalLimit, String intervalLimitAction, String intervalLimitFlag,
    DataTable table, String tableTSIDColumn, String tableTSIDFormat, String tableDateTimeColumn,
    String tableValuePreviousColumn, String tableValueColumn,
    String tableDeltaCalculatedColumn, String tableActionColumn, String tableDeltaColumn,
    String tableFlagColumn, String tableProblemColumn ) {
    this.__ts = ts;
    this.__analysisStart = analysisStart;
    this.__analysisEnd = analysisEnd;
    this.__trendType = trendType;
    if ( trendType == null ) {
    	// Default is no known trend.
        this.__trendType = TrendType.VARIABLE;
    }
    // Make sure that the trend type is handled.
    if ( (this.__trendType != TrendType.DECREASING) && (this.__trendType != TrendType.INCREASING) &&
        (this.__trendType != TrendType.VARIABLE) ) {
        throw new InvalidParameterException ( "Trend type \"" + trendType + "\" is invalid." );
    }
    this.__resetType = resetType;
    if ( resetType == null ) {
    	// Default is unknown reset type.
        this.__resetType = ResetType.UNKNOWN;
    }
    // Make sure that the reset type is handled.
    if ( (this.__resetType != ResetType.AUTO)
    	&& (this.__resetType != ResetType.ROLLOVER)
    	&& (this.__resetType != ResetType.UNKNOWN) ) {
        throw new InvalidParameterException ( "Reset type \"" + resetType + "\" is invalid." );
    }

    this.__deltaLimit = deltaLimit;
    this.__deltaLimitAction = deltaLimitAction;
    this.__deltaLimitFlag = deltaLimitFlag;
    this.__intervalLimit = intervalLimit;
    this.__intervalLimitAction = intervalLimitAction;
    this.__intervalLimitFlag = intervalLimitFlag;

    this.__autoResetDatum = autoResetDatum;
    if ( (this.__autoResetDatum == null) || this.__autoResetDatum.isEmpty() ) {
    	// Default is 0.
    	this.__autoResetDatumNumber = new Double(0.0);
    }
    else if ( autoResetDatum.equalsIgnoreCase("Auto") ) {
    	// Not yet handled.
   		throw new InvalidParameterException ( "Auto reset datum \"Auto\" is not yet handled.  Currently only a number is allowed." );
    }
    else {
    	// Not "auto" so must be a number.
    	if ( StringUtil.isDouble(autoResetDatum) ) {
    		this.__autoResetDatumNumber = Double.parseDouble(autoResetDatum);
    	}
    	else {
    		// Bad value.
    		throw new InvalidParameterException ( "Auto reset datum \"" + autoResetDatum + "\" is invalid.  Must be 'Auto' or a number." );
    	}
    }
    this.__resetMax = resetMax;
    this.__resetMin = resetMin;
    if ( ((this.__resetMax == null) && (this.__resetMin != null)) ||
    	((this.__resetMax != null) && (this.__resetMin == null)) ) {
        throw new InvalidParameterException ( "ResetMin and ResetMax must both be specified or both be null." );
    }
    if ( (this.__resetMax != null) && (this.__resetMax < 0.0) ) {
    	// TODO smalers 2023-03-22 don't handle negative.
        throw new InvalidParameterException ( "ResetMax must be positive." );
    }
    if ( (this.__resetMin != null) && (this.__resetMin < 0.0) ) {
    	// TODO smalers 2023-03-22 don't handle negative.
        throw new InvalidParameterException ( "ResetMin must be positive." );
    }
    if ( (this.__resetMin != null) && (this.__resetMax != null) && (this.__resetMin > this.__resetMax) ) {
        throw new InvalidParameterException ( "ResetMin must be less than ResetMax." );
    }
    // If reset type is ResetType.RESET_VALUE both reset minimum and maximum must be specified.
    if ( (this.__resetType == ResetType.ROLLOVER) && ((this.__resetMax == null) || (this.__resetMin == null)) ) {
        throw new InvalidParameterException ( "ResetMin and ResetMax must both be specified when reset type is "
        	+ ResetType.ROLLOVER + "." );
    }
    // If reset type is ResetType.AUTO both then trend type must be specified.
    if ( (this.__resetType == ResetType.AUTO) && (this.__trendType == null) ) {
        throw new InvalidParameterException ( "Reset type is " + ResetType.AUTO + " requires the trend type to be specified.");
    }
    this.__flag = flag;
    this.__createData = createData;

    // Table data.
    this.__table = table;
    this.__tableTSIDColumn = tableTSIDColumn;
    this.__tableTSIDFormat = tableTSIDFormat;
    this.__tableDateTimeColumn = tableDateTimeColumn;
    this.__tableValuePreviousColumn = tableValuePreviousColumn;
    this.__tableValueColumn = tableValueColumn;
    this.__tableDeltaCalculatedColumn = tableDeltaCalculatedColumn;
    this.__tableActionColumn = tableActionColumn;
    this.__tableDeltaColumn = tableDeltaColumn;
    this.__tableFlagColumn = tableFlagColumn;
    this.__tableProblemColumn = tableProblemColumn;
}

/**
 * Add a table record to save a problem that was detected.
 * @param table the table to update
 * @param tableTSID TSID for the new table record
 * @param dt DateTime for the new table record (corresponds to 'tsValue')
 * @param tsValuePrevious previous data value or null
 * @param tsValue current time series value (corresponds to 'dt')
 * @param deltaCalculated delta value from the initial calculation
 * @param action string indicating action that will be taken in response to the problem
 * @param delta final delta value after adjustment
 * @param deltaFlag flag to use (may be the singular flag for this problem)
 * @param problem a problem message describing the issue
 */
private void addTableRecord ( DataTable table, String tableTSID, DateTime dt, Double tsValuePrevious, double tsValue,
	double deltaCalculated, String action, double delta, String deltaFlag, String problem ) throws Exception {
   	// Save the results to the table.
	// Add a record to the table.
	TableRecord rec = table.emptyRecord();
	if ( this.__tableTSIDColumnNum >= 0 ) {
		rec.setFieldValue(this.__tableTSIDColumnNum, tableTSID);
	}
	if ( this.__tableDateTimeColumnNum >= 0 ) {
		// Make a copy of the DateTime since iterating.
		rec.setFieldValue(this.__tableDateTimeColumnNum, new DateTime(dt));
	}
	if ( this.__tableValuePreviousColumnNum >= 0 ) {
		rec.setFieldValue(this.__tableValuePreviousColumnNum, tsValuePrevious);
	}
	if ( this.__tableValueColumnNum >= 0 ) {
		rec.setFieldValue(this.__tableValueColumnNum, tsValue);
	}
	if ( this.__tableDeltaCalculatedColumnNum >= 0 ) {
		rec.setFieldValue(this.__tableDeltaCalculatedColumnNum, deltaCalculated);
	}
	if ( this.__tableActionColumnNum >= 0 ) {
		rec.setFieldValue(this.__tableActionColumnNum, action);
	}
	if ( this.__tableDeltaColumnNum >= 0 ) {
		rec.setFieldValue(this.__tableDeltaColumnNum, delta);
	}
	if ( this.__tableFlagColumnNum >= 0 ) {
		rec.setFieldValue(this.__tableFlagColumnNum, deltaFlag);
	}
	if ( this.__tableProblemColumnNum >= 0 ) {
		rec.setFieldValue(this.__tableProblemColumnNum, problem);
	}
	this.__table.addRecord(rec);
}

/**
Check that the output table is set up.  The following columns are included:
<ol>
<li>TSID</li>
<li>DateTime</li>
<li>ValuePrevious</li>
<li>Value</li>
<li>DeltaCalculated</li>
<li>Action</li>
<li>Delta</li>
<li>Flag</li>
<li>Problem</li>
</ol>
@param table table to set up
@param tableTSIDColumn name of column containing TSID
@param tableDateTimeColumn name of column containing date/time
@param tableValuePreviousColumn name of column containing value
@param tableValueColumn name of column containing value
@param tableValuePrecision precision for value columns (from time series precision)
@param tableDeltaCalculatedColumn name of column containing initial calculated delta
@param tableActionColumn name of column containing action (e.g., for exceeding delta limit)
@param tableDeltaColumn name of column containing final delta
@param tableFlagColumn name of column containing flag
@param tableProblemColumn name of column containing check message
@return true if table is being used, false if not.
*/
private boolean checkTableSetup ( DataTable table, String tableTSIDColumn, String tableDateTimeColumn,
	String tableValuePreviousColumn, String tableValueColumn, int tableValuePrecision,
	String tableDeltaCalculatedColumn, String tableActionColumn, String tableDeltaColumn,
	String tableFlagColumn, String tableProblemColumn ) {
	if ( table == null ) {
		return false;
	}
	// TSID
	try {
		if ( (tableTSIDColumn != null) && !tableTSIDColumn.isEmpty() ) {
			this.__tableTSIDColumnNum = table.getFieldIndex(tableTSIDColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it.
		this.__tableTSIDColumnNum = table.addField(new TableField(TableField.DATA_TYPE_STRING, tableTSIDColumn, -1, -1), "");
	}
	// DateTime
	try {
		if ( (tableDateTimeColumn != null) && !tableDateTimeColumn.isEmpty() ) {
			this.__tableDateTimeColumnNum = table.getFieldIndex(tableDateTimeColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it.
		this.__tableDateTimeColumnNum = table.addField(new TableField(TableField.DATA_TYPE_DATETIME, tableDateTimeColumn, -1, -1), "");
	}
	// ValuePrevious
	try {
		if ( (tableValuePreviousColumn != null) && !tableValuePreviousColumn.isEmpty() ) {
			this.__tableValuePreviousColumnNum = table.getFieldIndex(tableValuePreviousColumn);
		}
	}
	catch ( Exception e ) {
		// The table column is not found so create it.
		this.__tableValuePreviousColumnNum = table.addField(new TableField(TableField.DATA_TYPE_DOUBLE, tableValuePreviousColumn, -1, tableValuePrecision), "");
	}
	// Value
	try {
		if ( (tableValueColumn != null) && !tableValueColumn.isEmpty() ) {
			this.__tableValueColumnNum = table.getFieldIndex(tableValueColumn);
		}
	}
	catch ( Exception e ) {
		// The table column is not found so create it.
		this.__tableValueColumnNum = table.addField(new TableField(TableField.DATA_TYPE_DOUBLE, tableValueColumn, -1, tableValuePrecision), "");
	}
	// DeltaCalculated
	try {
		if ( (tableDeltaCalculatedColumn != null) && !tableDeltaCalculatedColumn.isEmpty() ) {
			this.__tableDeltaCalculatedColumnNum = table.getFieldIndex(tableDeltaCalculatedColumn);
		}
	}
	catch ( Exception e ) {
		// The table column is not found so create it.
		this.__tableDeltaCalculatedColumnNum = table.addField(new TableField(TableField.DATA_TYPE_DOUBLE, tableDeltaCalculatedColumn, -1, tableValuePrecision), "");
	}
	// Action
	try {
		if ( (tableActionColumn != null) && !tableActionColumn.isEmpty() ) {
			this.__tableActionColumnNum = table.getFieldIndex(tableActionColumn);
		}
	}
	catch ( Exception e ) {
		// The table column is not found so create it.
		this.__tableActionColumnNum = table.addField(new TableField(TableField.DATA_TYPE_STRING, tableActionColumn, -1, -1), "");
	}
	// Delta
	try {
		if ( (tableDeltaColumn != null) && !tableDeltaColumn.isEmpty() ) {
			this.__tableDeltaColumnNum = table.getFieldIndex(tableDeltaColumn);
		}
	}
	catch ( Exception e ) {
		// The table column is not found so create it.
		this.__tableDeltaColumnNum = table.addField(new TableField(TableField.DATA_TYPE_DOUBLE, tableDeltaColumn, -1, tableValuePrecision), "");
	}
	// Flag
	try {
		if ( (tableFlagColumn != null) && !tableFlagColumn.isEmpty() ) {
			this.__tableFlagColumnNum = table.getFieldIndex(tableFlagColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it.
		this.__tableFlagColumnNum = table.addField(new TableField(TableField.DATA_TYPE_STRING, tableFlagColumn, -1, -1), "");
	}
	// Problem
	try {
		if ( (tableProblemColumn != null) && !tableProblemColumn.isEmpty() ) {
			this.__tableProblemColumnNum = table.getFieldIndex(tableProblemColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it.
		this.__tableProblemColumnNum = table.addField(new TableField(TableField.DATA_TYPE_STRING, tableProblemColumn, -1, -1), "");
	}
	return true;
}

/**
Create a new time series that is the delta.
*/
public TS delta ()
throws Exception {
	String routine = null;
	boolean debug = Message.isDebugOn;
	if ( debug ) {
		routine = getClass().getSimpleName() + ".delta";
	}
    // Create a new list of problems.
    __problems = new ArrayList<>();
    // Initialize a new time series as a copy of the previous time series.
    TS ts = __ts;
    TS newts = TSUtil.newTimeSeries(ts.getIdentifier().getInterval(), false);
    newts.copyHeader( ts );
    newts.setMissing(Double.NaN); // Default missing data value is NaN.
    newts.setDataType(newts.getDataType() + "-Delta" );
    if ( __analysisStart != null ) {
        newts.setDate1 ( __analysisStart );
    }
    if ( __analysisEnd != null ) {
        newts.setDate2 ( __analysisEnd );
    }
    if ( (__flag != null) && !__flag.equals("") ) {
        newts.hasDataFlags(true,true);
    }
    
    // If the delta limit is being checked and out of range will be set to missing, set a boolean to streamline.
    boolean doDeltaLimitSetMissing = false;
    if ( (this.__deltaLimit != null) && (this.__deltaLimitAction != null) && (this.__deltaLimitAction.equalsIgnoreCase("SetMissing")) ) {
    	doDeltaLimitSetMissing = true;
    }

    // If the interval limit is being checked and out of range will be set to missing, set a boolean to streamline.
    boolean doIntervalLimitSetMissing = false;
    if ( (this.__intervalLimit != null) && (this.__intervalLimitAction != null) && (this.__intervalLimitAction.equalsIgnoreCase("SetMissing")) ) {
    	doIntervalLimitSetMissing = true;
    }

    // If a table is being used for output, check that it has the required columns.
    boolean doTable = false;
    String tableTSID = ""; // Time series TSID formatted for table.
    int tableValuePrecision = 4;
    if ( this.__table != null ) {
    	doTable = checkTableSetup(this.__table, this.__tableTSIDColumn, this.__tableDateTimeColumn,
    		 this.__tableValuePreviousColumn, this.__tableValueColumn, tableValuePrecision,
    		 this.__tableDeltaCalculatedColumn, this.__tableActionColumn, this.__tableDeltaColumn,
    		 this.__tableFlagColumn, this.__tableProblemColumn ); 
    	// Format the TSID for output to the TSID column in the table.
    	tableTSID = newts.formatLegend(__tableTSIDFormat);
    }

    if ( __createData ) {
        newts.allocateDataSpace();
        // Loop through the time series data.
        TSIterator tsi = ts.iterator(this.__analysisStart, this.__analysisEnd);
        TSData tsdata;
        // Initialize the previous values to missing.
        double newMissing = newts.getMissing();
        double valuePrev = ts.getMissing(); // Previous value from time series.
        double value; // Current value from time series.
        double delta = 0.0; // Difference between current and previous value.
        DateTime dt, dtPrev = null;
        // Set local data based on the reset type:
        // - set booleans to streamline logic
        boolean doResetRollover = false;
        boolean doResetAuto = false;
        double resetMin = 0.0, resetMax = 0.0;
        if ( this.__resetType == ResetType.AUTO ) {
        	doResetAuto = true;
        }
        else if ( this.__resetType == ResetType.ROLLOVER ) {
       	    doResetRollover = true;
        	if ( __resetMin != null ) {
          	   resetMin = __resetMin.doubleValue();
         	}
        	if ( __resetMax != null ) {
           	  resetMax = __resetMax.doubleValue();
         	}
        }
        // Determine the flags to use for labeling problem points.
        String resetFlagHigh = null; // Value during reset is out of range high.
        String resetFlagLow = null; // Value during reset is out of range low.
        String valueFlagHigh = null; // Value outside of reset is out of range high.
        String valueFlagLow = null; // Value outside of reset is out of range low.
        
        // Determine whether the output time series is regular interval.
        boolean tsIsRegular = TimeInterval.isRegularInterval(ts.getDataIntervalBase());

        if ( doResetRollover && (__flag != null) ) {
        	// Set the flag values and descriptions in the time series.
            if ( __flag.equalsIgnoreCase("Auto") ) {
                resetFlagHigh = "+R"; // Append reset high.
                resetFlagLow = "+r"; // Append reset low.
                valueFlagHigh = "+V";
                valueFlagLow = "+v";
                // Add metadata without +
                newts.addDataFlagMetadata(new TSDataFlagMetadata("R", "Previous value for reset is > ResetMax (" +
                    StringUtil.formatString(resetMax,"%.6f") + ") - delta may be in error."));
                newts.addDataFlagMetadata(new TSDataFlagMetadata("r", "Previous value for reset is < ResetMin (" +
                    StringUtil.formatString(resetMin,"%.6f") + ") - delta may be in error"));
                newts.addDataFlagMetadata(new TSDataFlagMetadata("V", "Value is > ResetMax (" +
                    StringUtil.formatString(resetMax,"%.6f") + ")."));
                newts.addDataFlagMetadata(new TSDataFlagMetadata("v", "Value is < ResetMin (" +
                    StringUtil.formatString(resetMin,"%.6f") + ")."));
            }
            else {
                // Use the specified flag for all cases.
                resetFlagHigh = __flag;
                resetFlagLow = __flag;
                valueFlagHigh = __flag;
                valueFlagLow = __flag;
            }
        }
        boolean isDeltaCalculated; // Used to determine if the delta has been computed.
        boolean doIntervalCheck; // Whether to check the interval limit, set for each value processed.
        double deltaAbs; // Absolute value of 'delta'.
        String flag = null; // Used to flag bad values.
        DateTime dtIntervalLimit = null; // Used to check the IntervalLimit.
        DateTime dtPrevSearch = null; // Used to search for previous value when doing an interval check.
        // Count of cases where 'valuePrev' and 'value' are both non-missing, used when doing the interval check.
        int okDataCount = 0;
        // Use iterator over the original time series and set in the new time series by specific date/time.
        // Make sure that the loop completes (no "continue" so that previous iteration values are set).
        while ( (tsdata = tsi.next()) != null ) { // 'tsdata' is reused - don't use below when setting the flag.
            dt = tsdata.getDate();
            value = tsdata.getDataValue();
            isDeltaCalculated = false;
            flag = null;
            // Control whether to do the interval check for each value:
            // - default is to do the check if the interval limit was specified
            // - may disable if a reset is processed because the reset discontinuity,
            //   especially for rollover start-up after sensor maintenance would not pass the interval check
            // - set to false below in reset code
            doIntervalCheck = true;
            if ( (this.__intervalLimit != null) && (dtIntervalLimit == null) ) {
            	// DateTime used for IntervalLimit check:
            	// - initialize to the first date/time
            	// - will set the 'dtIntervalLimi' parts below when checking the interval
            	dtIntervalLimit = new DateTime(dt);
            }
            // Create a date/time consistent with the time series, for interval check search:
            // - this improves performance by not creating a new DateTime for each value
            if ( dtPrevSearch == null ) {
            	dtPrevSearch = new DateTime(dt);
            }
            // Can only compute the delta if the previous value was not missing.
            if ( !ts.isDataMissing(valuePrev) && !ts.isDataMissing(value) ) {
            	// Increment the okDataCount to know when past the start of the period.
            	++okDataCount;
                // Have non-missing current and previous values so can compute the delta.
            	if ( doResetAuto) {
            		// Allow resets based on change in direction so that the deltas are always the same sign:
            		// - for increasing trend, all deltas will be positive
            		// - for negative trend, all deltas will be negative
                    if ( __trendType == TrendType.DECREASING ) {
                    	// Expected trend is decreasing so a positive change is a reset.
                    	/* TODO smalers 2023-03-26 need to figure out, could have negative budget
                        if ( value < this.__autoResetDatumNumber ) {
                        	// Value below the datum is not expected:
                        	// - allow but generate a problem message
                            this.__problems.add( "Value " + value + " at " + dt
                            	+ " is < the auto reset datum (" + this.__autoResetDatum +
                            	").  Auto-resetting the delta to zero." );
                            delta = 0.0;
                        }
                        */
                        if ( value > valuePrev ) {
                        	if ( debug ) {
                        		Message.printStatus ( 2, routine, "At " + dt +
                        			" increase detected for decreasing trend so resetting to value=value");
                        	}
                        	// Have no upper bound like with rollover:
                        	// - cannot add increment before the reset
                        	// - delta is current value minus previous
                        	delta = value - valuePrev;
                        }
                        else {
                        	// Trend is still decreasing.
                        	delta = value - valuePrev;
                        }
                        isDeltaCalculated = true;
                    }
                    else if ( __trendType == TrendType.INCREASING ) {
                    	// Expected trend is increasing so a negative change is a reset.
                        if ( value < this.__autoResetDatumNumber ) {
                        	// Value below the datum is not expected:
                        	// - allow but generate a problem message
                            this.__problems.add( "Value " + value + " at " + dt
                            	+ " is < the auto reset datum (" + this.__autoResetDatum +
                            	").  Auto-resetting the delta to zero." );
                            delta = 0.0;
                        }
                        else if ( value < valuePrev ) {
                        	if ( debug ) {
                        		Message.printStatus ( 2, routine, "At " + dt +
                        			" decrease detected for increasing trend so resetting to value=value");
                        	}
                        	// Have no upper bound like with rollover:
                        	// - cannot add increment before the reset
                        	// - delta is just the value measured up from the datum)
                        	delta = (value - this.__autoResetDatumNumber);
                        }
                        else {
                        	// Trend is still increasing.
                        	delta = value - valuePrev;
                        }
                        isDeltaCalculated = true;
                    }
            	}
            	else if ( doResetRollover ) {
                    // The reset handling is based on the trend parameter and reset minimum and maximum.
                    // The delta is computed as the change to the first reset (e.g., to resetMax) plus the change
                    // from the second reset (e.g., resetMin to current value).
                    if ( this.__trendType == TrendType.DECREASING ) {
                    	// TODO smalers 2023-3-26 Need to evaluate the logic with automated tests when there is time.
                        if ( value > valuePrev ) {
                        	// A reset has occurred.
                        	if ( debug ) {
                        		Message.printStatus ( 2, routine, "At " + dt + " delta computed inside reset.");
                        	}
                            // Value increased so account for reset.
                            if ( valuePrev < resetMin ) {
                                // Previous value was above the maximum so can't compute delta component on top
                                // of the previous value.
                                __problems.add( "Previous value " + valuePrev + " at " + dtPrev + " is < ResetMin " +
                                    resetMax + ".  Ignoring ambiguous amount below ResetMin in previous value for delta." );
                                delta = 0.0;
                                flag = resetFlagLow; // Will flag the data to indicate overrun (out of range).
                            }
                            else {
                                // Assume that the previous value transitioned to the min, up to the max, and then to the new value.
                                // This will be a negative number
                                delta = resetMin - valuePrev;
                            }
                            // Now add the top part of the reset.
                            if ( value > resetMax ) {
                                __problems.add( "Value " + value + " at " + dt + " is > ResetMax " +
                                    resetMin + ".  Adding amount above ResetMax to delta (decrease magnitude of negative delta)." );
                                flag = resetFlagHigh; // Will flag the data to indicate underrun (out of range).
                                delta += (value - resetMax);
                            }
                            else {
                                delta -= (resetMax - value);
                            }
                            // The delta has been computed so no need to compute below.
                            isDeltaCalculated = true;
                        }
                        else {
                        	// Value is still decreasing:
                        	// - simple math
                        	delta = (value - valuePrev);
                        }
                    }
                    else if ( __trendType == TrendType.INCREASING ) {
                        if ( value < valuePrev ) {
                        	// Value decreased from previous so assume that it is a reset.
                        	if ( debug ) {
                        		Message.printStatus ( 2, routine, "At " + dt + " delta computed inside reset.");
                        	}
                            if ( valuePrev > resetMax ) {
                                // Previous value was above the maximum so can't compute delta component on top
                                // of the previous value.
                                __problems.add( "Previous value " + valuePrev + " at " + dtPrev + " is > ResetMax " +
                                    resetMax + ".  Ignoring ambiguous amount above ResetMax in previous value for delta." );
                                delta = 0.0;
                                flag = getFlag (
            			            "", // No flag is the global default.
            			            null, // User supplied flag for delta limit.
            			            resetFlagHigh, // Default if "Auto" is specified.
            			            this.__flag ); // Global general flag.
            		            if ( doTable ) {
            		    	        String action = "";
            		    		    action = "";
            		    		    Double deltaCalculated = 0.0;
            		    		    addTableRecord(this.__table, tableTSID, dtPrev, valuePrev, value,
            			    	         deltaCalculated, action, delta, flag,
            				             String.format("Previous value " + valuePrev + ") > ResetMax %f", this.__resetMax) );
            		             }
                            }
                            else {
                                // Assume that the previous value transitioned to the max and then to the new value.
                                delta = resetMax - valuePrev;
                            }
                            // Now add the bottom part of the reset.
                            if ( value < resetMin ) {
                                __problems.add( "Value " + value + " at " + dt + " is < ResetMin " +
                                    resetMin + ".  Subtracting amount below ResetMin from delta." );
                                delta -= (resetMin - value);
                                flag = getFlag (
            			            "", // No flag is the global default.
            			            null, // User supplied flag for delta limit.
            			            resetFlagLow, // Default if "Auto" is specified.
            			            this.__flag ); // Global general flag.
            		            if ( doTable ) {
            		    	        String action = "";
            		    		    action = "";
            		    		    Double deltaCalculated = delta;
            		    		    addTableRecord(this.__table, tableTSID, dtPrev, valuePrev, value,
            			    	         deltaCalculated, action, delta, flag,
            				             String.format("Value " + value + ") > ResetMin %f", this.__resetMin) );
            		             }
                            }
                            else if ( value > resetMax ) {
                                __problems.add( "Value " + value + " at " + dt + " is > ResetMax " +
                                    resetMax + ".  Setting to missing.  Have a major data problem." );
                                delta = newMissing;
                                flag = getFlag (
            			            "", // No flag is the global default.
            			            null, // User supplied flag for delta limit.
            			            resetFlagHigh, // Default if "Auto" is specified.
            			            this.__flag ); // Global general flag.
            		            if ( doTable ) {
            		    	        String action = "";
            		    		    action = "";
            		    		    Double deltaCalculated = delta;
            		    		    addTableRecord(this.__table, tableTSID, dtPrev, valuePrev, value,
            			    	         deltaCalculated, action, delta, flag,
            				             String.format("Value " + value + ") > ResetMax %f", this.__resetMax) );
            		             }
                            }
                            else {
                            	// Add the increment to the delta.
                                delta += (value - resetMin);
                            }
                            // The delta has been computed so no need to compute below.
                            isDeltaCalculated = true;
                        }
                    }
                    if ( !isDeltaCalculated ) {
                    	// Also generate warnings for out of range values that will skew the delta.
                    	// Reset limits were specified but a reset was not detected above - do range check.
                    	if ( value < resetMin ) {
                        	__problems.add( "Value " + value + " at " + dt + " is < ResetMin " +
                            	resetMin + ".  Delta may be in error." );
                            flag = getFlag (
          			            "", // No flag is the global default.
        			            null, // User supplied flag for delta limit.
        			            valueFlagLow, // Default if "Auto" is specified.
        			            this.__flag ); // Global general flag.
        		            if ( doTable ) {
        		    	        String action = "";
        		    		    action = "";
        		    		    Double deltaCalculated = delta;
        		    		    addTableRecord(this.__table, tableTSID, dtPrev, valuePrev, value,
        			    	         deltaCalculated, action, delta, flag,
        				             String.format("Value " + value + ") < ResetMin %f", this.__resetMin) );
        		            }
                    	}
                    	else if ( value > resetMax ) {
                        	__problems.add( "Value " + value + " at " + dt + " is > ResetMax " +
                            	resetMax + ".  Delta may be in error." );
                       		if ( debug ) {
                       			Message.printStatus(2, routine, __problems.get(__problems.size() - 1));
                       		}
                            flag = getFlag (
          			            "", // No flag is the global default.
        			            null, // User supplied flag for delta limit.
        			            valueFlagHigh, // Default if "Auto" is specified.
        			            this.__flag ); // Global general flag.
        		            if ( doTable ) {
        		    	        String action = "";
        		    		    action = "";
        		    		    Double deltaCalculated = delta;
        		    		    addTableRecord(this.__table, tableTSID, dtPrev, valuePrev, value,
        			    	         deltaCalculated, action, delta, flag,
        				             String.format("Value " + value + ") > ResetMax %f", this.__resetMax) );
        		            }
                    	}
                    	// Calculate the delta using simple math.
                    	delta = value - valuePrev;
                        isDeltaCalculated = true;
                    }
                }
            	else {
            		// Reset type is unknown:
                    // - simple difference calculation
            		delta = value - valuePrev;
                    isDeltaCalculated = true;
            	}
            }
            if ( isDeltaCalculated ) {
                // The delta was computed so set the value.
               	if ( debug ) {
               		Message.printStatus(2, routine, "At " + dt + " delta calculated is " + delta + " flag is \"" + flag + "\"" );
               	}

                // Check whether the delta exceeds delta limit.
                double deltaCalculated = delta;
                deltaAbs = Math.abs(delta);
                if ( this.__deltaLimit != null ) {
            	    // Check the calculated delta against the limit.
            	    if ( deltaAbs > this.__deltaLimit ) {
            		    flag = getFlag (
            			    "", // No flag is the global default.
            			    this.__deltaLimitFlag, // Flag for delta limit.
            			    "+L", // Default if "Auto" is specified.
            			    this.__flag ); // Global general flag.
            		    if ( doDeltaLimitSetMissing ) {
            			    // Reset the delta value here so that it is set below.
            			    delta = newMissing;
            		    }
            		    if ( doTable ) {
            		    	String action = "";
            		    	if ( this.__deltaLimitAction != null ) {
            		    		action = this.__deltaLimitAction;
            		    	}
            			    addTableRecord(this.__table, tableTSID, dtPrev, valuePrev, value,
            			    	deltaCalculated, action, delta, flag,
            				    String.format("Calculated abs(delta value " + deltaCalculated + ") > limit %f", this.__deltaLimit) );
            		    }
            			this.__problems.add	( String.format("Calculated abs(delta value %f) > limit %f", deltaCalculated, this.__deltaLimit));
            	    }
                }

                if ( (this.__intervalLimit != null) && doIntervalCheck ) {
            	    // Check the interval between current and previous value against the interval limit.
                	//
                	// dtIntervalLimit   dtPrevious     dt
                	//      |                 |          |         OK
                	//
                	//
                	// dtPrevious     dtIntervalLImit   dt
                	//      |                 |          |         Not OK.
                	//
                	dtIntervalLimit.setDate(dt);
                	// Decrement by the interval limit.
                	dtIntervalLimit.addInterval(this.__intervalLimit.getBase(), -this.__intervalLimit.getMultiplier());
                	// If irregular interval can check the previous date/time.
                	// If regular, search backwards for the first value that has a value or flag, which indicates non-missing
                	if ( tsIsRegular ) {
                		dtPrevSearch = findPreviousDateTime(ts, this.__analysisStart, dt);
                	}
                	else {
                		// Assume that irregular interval data indicate data reports such as regular reports and events
                		// so don't check for missing.
                		dtPrevSearch = dtPrev;
                	}
                	//Message.printStatus(2, routine, "dtPrevSearch=" + dtPrevSearch + ", dtIntervalLimit=" + dtIntervalLimit + ", dt=" + dt);
                	if ( (okDataCount >= 1) && dtIntervalLimit.greaterThan(dtPrevSearch) ) {
            	    	// Copy the current date/time into the check:
                		// - the check on 'okDataCount' is needed because dtPrevSearch may be null at the beginning of the analysis period
            		    flag = getFlag (
            			    "", // No flag is the global default.
            			    this.__intervalLimitFlag, // Flag for interval limit.
            			    "+I", // Default if "Auto" is specified.
            			    this.__flag ); // Global general flag.
            		    if ( doIntervalLimitSetMissing ) {
            			    // Reset the delta value here so that it is set below.
            			    delta = newMissing;
            		    }
            		    if ( doTable ) {
            		    	String action = "";
            		    	if ( this.__intervalLimitAction != null ) {
            		    		action = this.__intervalLimitAction;
            		    	}
            			    addTableRecord(this.__table, tableTSID, dtPrev, valuePrev, value,
            			    	deltaCalculated, action, delta, flag,
            				    ("Period between previous (" + dtPrev + ") and current (" + dt + ") > "
            			    	+ this.__intervalLimit) + " interval limit." );
            		    }
            			this.__problems.add	("Period between previous (" + dtPrev + ") and current (" + dt + ") > "
            		    	+ this.__intervalLimit + " interval limit." );
            	    }
                }

                if ( flag != null ) {
                    // Set the data value and flag (duration left as before).
                    newts.setDataValue(dt, delta, TSData.appendDataFlag(tsdata.getDataFlag(),flag), tsdata.getDuration());
                }
                else {
                    newts.setDataValue(dt, delta);
                }

            }
            else {
            	// Fall through in cases where missing was encountered is to leave the new time series missing.
            	// However, for irregular time series,
            	// add a missing value in the output time series at the date to be consistent with the input time series.
               	if ( debug ) {
               		Message.printStatus(2, routine, "At " + dt + " delta not computed - set to missing " + newMissing +
               				" flag is \"" + flag + "\"." );
               	}
                if ( flag != null ) {
                    // Set the data value and flag (flag can have value even if data value is missing).
                    newts.setDataValue(dt, newMissing, TSData.appendDataFlag(tsdata.getDataFlag(),flag), tsdata.getDuration());
                }
                else {
                    newts.setDataValue(dt, newMissing);
                }
            }
            // Set the previous value for the next iteration.
            valuePrev = value;
            dtPrev = dt;
           	if ( debug ) {
           		Message.printStatus(2, routine, "At " + dt + " TS value after set is " + newts.getDataValue(dt) + " flag \"" +
           			newts.getDataPoint(dt,null).getDataFlag() + "\"");
           	}
        }
    }

    return newts;
}

/**
 * Get the previous DateTime with non-missing data given a start.
 * @param ts time series being processed
 * @param analysisStart the start of the analysis, to limit the search
 * @param dt starting DateTime
 * @return the nearest previous DateTime with a non-missing data value
 */
private DateTime findPreviousDateTime ( TS ts, DateTime analysisStart, DateTime dt ) throws Exception { 
	TSIterator tsi = ts.iterator(analysisStart, dt);
	
	TSData tsdata;
    while ( (tsdata = tsi.previous()) != null ) {
    	if ( !ts.isDataMissing(tsdata.getDataValue()) ) {
    		return tsdata.getDate();
    	}
    }
    return null;
}

/**
 * Get the flag to use.
 * @param defaultNoFlag default if no flag parameters are specified
 * @param requestedFlag requested specific flag
 * @param autoFlag flag to use if 'requestedFlag' or 'globalFlag' is Auto
 * @param globalFlag global flag to use for all flags
 */
private String getFlag ( String defaultNoFlag, String requestedFlag, String autoFlag, String globalFlag ) {
    String tsFlag = defaultNoFlag;
    if ( (requestedFlag != null) && !requestedFlag.isEmpty() ) {
    	if ( requestedFlag.equalsIgnoreCase("Auto") ) {
    		// Auto is requested.
    		tsFlag = autoFlag;
    	}
    	else {
    		// Use the user-specified flag.
    		tsFlag = requestedFlag;
    	}
    }
    else {
    	// Use the global flag if specified.
    	if ( (globalFlag != null) && !globalFlag.isEmpty() ) {
    		if ( globalFlag.equalsIgnoreCase("Auto") ) {
    			// Use the default "Auto" flag.
    			tsFlag = autoFlag;
    		}
    		else {
    			// Use the user-specified global flag.
    			tsFlag = globalFlag;
    		}
    	}
    }
    return tsFlag;
}

/**
Return a list of problems for the time series.
*/
public List<String> getProblems () {
    return __problems;
}

}