package RTi.TS;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;

import RTi.Util.Math.BestFitIndicatorType;
import RTi.Util.Math.DataTransformationType;
import RTi.Util.Math.NumberOfEquationsType;
import RTi.Util.Math.RegressionFilledValues;
import RTi.Util.Math.RegressionType;
import RTi.Util.Message.Message;
import RTi.Util.String.StringUtil;
import RTi.Util.Table.DataTable;
import RTi.Util.Table.TableField;
import RTi.Util.Table.TableRecord;
import RTi.Util.Time.DateTime;
import RTi.Util.Time.TimeUtil;

/**
Helper class to help with FillRegression and FillMOVE2 commands.
*/
public class TSUtil_FillRegression
{

/**
Time series being filled.
*/
private TS __tsToFill = null;

/**
Analysis method (regression type).
*/
private RegressionType __analysisMethod = RegressionType.OLS_REGRESSION; // Default

/**
Indicates whether to fill with one equation or monthly equations.
*/
private NumberOfEquationsType __numberOfEquations = null;

/**
List of month numbers to analyze when using one equation, where each month is 1-12 (Jan - Dec),
or null to analyze all months.
*/
private int [] __analysisMonths = null;

/**
Data value to substitute for the original when using a log transform and the original value is <= 0.
Can be any number > 0.
TODO SAM 2010-12-17 Allow NaN to throw the number away, but this changes counts, etc.
*/
private Double __leZeroLogValue = new Double(TSRegressionAnalysis.getLEZeroLogValueDefault()); // Default

/**
The intercept to force, or null if not forcing.  If set, only zero is allowed and it is only used with
OLS regression.
*/
private Double __forcedIntercept = null;

/**
Analysis period start for the dependent (Y) time series.
*/
private DateTime __dependentAnalysisStart = null;

/**
Analysis period end for the dependent (Y) time series.
*/
private DateTime __dependentAnalysisEnd = null;

/**
Analysis period start for the independent (X) time series.  For OLS and MOVE2,
this is the same as the dependent analysis period.  For MOVE2 it can be different.
*/
private DateTime __independentAnalysisStart = null;

/**
Analysis period end for the independent (X) time series.  For OLS and MOVE2,
this is the same as the dependent analysis period.  For MOVE2 it can be different.
*/
private DateTime __independentAnalysisEnd = null;

/**
Minimum sample size needed for a good relationship.
*/
private Integer __minimumSampleSize = null;

/**
Minimum R needed for a good relationship;
*/
private Double __minimumR = null;

/**
Start of filling.
*/
private DateTime __fillStart;

/**
End of filling.
*/
private DateTime __fillEnd;

/**
Flag to mark filled values.
*/
private String __fillFlag = null;

/**
Fill flag description.
*/
private String __fillFlagDesc = null;

/**
Whether to actually do the filling (or just compute the relationships).
*/
private boolean __doFill = true;

/**
Description string to append to time series description, rather than using default.
*/
private String __descriptionString = null;

/**
The list of TSRegressionAnalysis objects for mixed station.
*/
private List<TSRegressionAnalysis> __tsRegressionAnalysisList = null;

/**
The TSRegressionFilledValues object that contains information about filled values.
*/
private TSRegressionFilledValues __tsRegressionFilledValues = null;
    
/**
List of runtime errors generated by this command, guaranteed to be non-null.
*/
private List<String> __problems = new Vector<String>();
    
/**
How should values be sorted for fill mixed station?
*/
private BestFitIndicatorType __bestFit;

/**Constructor.
 * 
 * @param analysisMethod What kind of analysis to use? Currently only OLS regression is supported.
 * @param numberOfEquations Monthly, single, or both?
 * @param analysisMonths Which months should I be looking at?
 * @param transformation Untransformed data or log? (more might be supported later)
 * @param leZeroLogValue If the value is 0 and it's a log transform, what should I use?
 * @param forcedIntercept Force the regression line to go through this point.
 * @param dependentAnalysisStart When to start looking for data?
 * @param dependentAnalysisEnd When to end?
 * @param independentAnalysisStart Currently should be same as dependent; exists to ease implementation of other analysis types.
 * @param independentAnalysisEnd Currently should be same as dependent; exists to ease implementation of other analysis types.
 * @param minimumSampleSize How much overlap between dependent and independent is necessary (if unspecified, defaults to 3).
 * @param minimumR How large does the correlation coefficient need to be?
 * @param confidenceIntervalPercent What t-test value does it need to pass?
 * @param fillStart When to start filling?
 * @param fillEnd When to end?
 * @param fillFlag What should mark filled values?
 * @param fillFlagDesc What describes that flag?
 * @param descriptionString
 * @param tsRegressionAnalysisList The analyses to use to fill.
 */
public TSUtil_FillRegression(TS dependent, RegressionType analysisMethod,
		int[] analysisMonths,
		Double leZeroLogValue,
		Double forcedIntercept, DateTime dependentAnalysisStart,
		DateTime dependentAnalysisEnd, DateTime independentAnalysisStart,
		DateTime independentAnalysisEnd, Integer minimumSampleSize,
		Double minimumR, Double confidenceIntervalPercent, DateTime fillStart,
		DateTime fillEnd, String fillFlag, String fillFlagDesc,
		String descriptionString, BestFitIndicatorType sortMethod,
		List<TSRegressionAnalysis> tsRegressionAnalysisList) {
	
	__tsToFill = dependent;
	__analysisMethod = analysisMethod;
	__analysisMonths = analysisMonths;
	if (leZeroLogValue != null) {
		__leZeroLogValue = leZeroLogValue;
	}
	__forcedIntercept = forcedIntercept;
    // Dependent analysis period
    // If dates are null, get from the time series
    if ( dependentAnalysisStart == null ) {
        __dependentAnalysisStart = new DateTime(__tsToFill.getDate1());
    }
    else {
        __dependentAnalysisStart = new DateTime(dependentAnalysisStart);
    }
    if ( dependentAnalysisEnd == null ) {
        __dependentAnalysisEnd = new DateTime(__tsToFill.getDate2());
    }
    else {
        __dependentAnalysisEnd = new DateTime(dependentAnalysisEnd);
    }
    // Independent analysis period...
    if ( __analysisMethod == RegressionType.OLS_REGRESSION ) {
        // Independent analysis period is the same as the dependent...
        __independentAnalysisStart = new DateTime(__dependentAnalysisStart);
        __independentAnalysisEnd = new DateTime(__dependentAnalysisEnd);
    }
    //no clue what to do for non-OLS

    if (minimumSampleSize != null && minimumSampleSize >= 3) {
    	__minimumSampleSize = minimumSampleSize;
    }
    else {
    	//necessary because at one point we divide by sample size - 2....
    	__minimumSampleSize = 3;
    }
	__minimumR = minimumR;
    if ( fillStart == null ) {
        __fillStart = new DateTime(__tsToFill.getDate1());
    }
    else {
        __fillStart = new DateTime(fillStart);
    }
    if ( fillEnd == null ) {
        __fillEnd = new DateTime(__tsToFill.getDate2());
    }
    else {
        __fillEnd = new DateTime(fillEnd);
    }
	__fillFlag = fillFlag;
	__fillFlagDesc = fillFlagDesc;
	__descriptionString = descriptionString;
	
	__bestFit = sortMethod;
	__tsRegressionAnalysisList = tsRegressionAnalysisList;
}

/**
Determine the flag to tag the filled time series values.
@param numEquations 1 or 12 if monthly equations
@param iEquation equation being processed (1+).
@param rank rank for independent time series relationship.
@return string flag to tag time series
*/
private String determineFillFlag ( int numEquations, int iEquation, int rank )
{
    if ( numEquations == 1 ) {
        return "" + rank;
    }
    else {
        // Monthly
        return TimeUtil.monthAbbreviation(iEquation) + rank;
    }
}

/**
Fill the dependent time series
*/
public void fill() {
	String routine = getClass().getName() + "TSUtil.fillMixedStation";
    int dl = 10; // Debug level

    List<String> problems = getProblems();
    TS tsToFill = getTSToFill();
    String fillFlag = getFillFlag();
    
    Double leZeroLogValue = getLEZeroLogValue();
    double leZeroLogValue2 = Math.log10(leZeroLogValue);
    
    int intervalBase = tsToFill.getDataIntervalBase();
    int intervalMult = tsToFill.getDataIntervalMult();

    boolean fillFlag_boolean = false; // Indicate whether to use flag
    if ( (fillFlag != null) && (fillFlag.length() > 0) ) {
        fillFlag_boolean = true;
    }

    DateTime fillStart = getFillStart();
    DateTime fillEnd = getFillEnd();

    int errorCount = 0; // Count of errors filling (limited to 100 because most likely a logic issue)
    int fillCountSingle = 0; // To know whether to add to genesis
    int [] fillCountMonthly = new int[12];
    // Arrays for filled values, used to compute post-filling statistics
    int fullDataCount = TSUtil.calculateDataSize(tsToFill, fillStart, fillEnd);
    double [] singleEquationFilledValues = new double[fullDataCount];
    double [][] monthlyEquationFilledValues = new double[12][fullDataCount];
    Message.printStatus ( 2, routine, "Filling dependent time series " +
        tsToFill.getIdentifier().toStringAliasAndTSID() + " from " + fillStart + " to " + fillEnd );
    for ( DateTime date = new DateTime ( fillStart ); date.lessThanOrEqualTo( fillEnd );
        date.addInterval(intervalBase, intervalMult) ) {
        int month = date.getMonth();
        try {
            // TODO SAM - need to evaluate this - use isAnalyzed() to improve performance
            if ( tsToFill.isDataMissing(tsToFill.getDataValue(date)) ) {
                // Try to fill the value...
            	
                Double SEP = Double.MAX_VALUE;
                Double R = -Double.MAX_VALUE;
            	boolean firstTime = true;
                
            	for (TSRegressionAnalysis analysis: __tsRegressionAnalysisList) {
            		
            	    double newval = 0.0, x = 0.0;
            	    TS tsIndependent = analysis.getIndependentTS();
            	    boolean [] analysisMonthsMask = analysis.getAnalysisMonthsMask();
            	    boolean fillSingle = analysis.getAnalyzeSingleEquation();
            	    
            	    boolean [] regressionChecksMask = null;
            	    
            	    if ( fillSingle ) {
            	        regressionChecksMask = analysis.getTSRegressionChecksMaskSingle();
            	    }
            	    else {
            	        regressionChecksMask = analysis.getTSRegressionChecksMaskMonthly();
            	    }
            		
            	    x = tsIndependent.getDataValue ( date );
                    if ( tsIndependent.isDataMissing(x) || x == 0 ) {
                        // No independent value so can't fill
                    	// 0's excluded in mixed station, so exclude them here as well...
                        continue;
                    }
                    // Skip the month if not requested
                    if ( !analysisMonthsMask[month - 1] ) {
                        continue;
                    }
                    if ( !regressionChecksMask[month - 1] ) {
                        // Don't have a valid relationship to do filling for the specific month so skip value
                        continue;
                    }            		
            		
            		//go through each independent that passed the requirements
            	    TSRegressionResults analysisResults = null;
            	    TSRegressionData analysisData = null;
            	    TSRegressionEstimateErrors errors = null;
            	    double a, b; // Coefficients for regression relationship
            	    double r; //correlation coefficient, used only for sorting
            	    int n1; //number of overlapping values
            	    double xbar; //mean
            	    double var; //variance
            	    Double see; //standard error of estimate
            	    DataTransformationType transformation = analysis.getTransformation();
            	    
            	    if ( transformation == DataTransformationType.NONE ) {
            	        analysisResults = analysis.getTSRegressionResults();
            	        analysisData = analysis.getTSRegressionData();
            	        errors = analysis.getTSRegressionEstimateErrors();
            	    }
            	    else {
            	        analysisResults = analysis.getTSRegressionResultsTransformed();
            	        analysisData = analysis.getTSRegressionDataTransformed();
            	        errors = analysis.getTSRegressionErrorsTransformed();
            	    }
            	    
                    Message.printStatus(2, routine, "Dependent "+tsToFill.getLocation()+" and independent "+tsIndependent.getLocation()
                    		+!fillSingle+" have a valid relationship at "+date);
                    if ( Message.isDebugOn ) {
                        Message.printDebug ( dl, routine, "Filling dependent, found nonmissing independant data at " + date + " - value: " + x  );
                    }
                    if ( transformation == DataTransformationType.LOG ) {
                        // Need to work on the log of the X value...
                        if ( x <= 0.0 ) {
                            // Use the specified value for small independent
                            x = leZeroLogValue2;
                        }
                        else {
                            x = Math.log10(x);
                        }
                        if ( Message.isDebugOn ) {
                            Message.printDebug ( dl, routine, "Using log10(independent value): " + x);
                        }
                    }

                    if ( fillSingle ) {
                        a = analysisResults.getSingleEquationRegressionResults().getA();
                        b = analysisResults.getSingleEquationRegressionResults().getB();
                        r = analysisResults.getSingleEquationRegressionResults().getCorrelationCoefficient();
                        n1 = analysisData.getSingleEquationRegressionData().getN1();
                        xbar = analysisData.getSingleEquationRegressionData().getMeanX1();
                        var = Math.pow(analysisData.getSingleEquationRegressionData().getStandardDeviationX1(),2);
                        see = errors.getSingleEquationRegressionErrors().getStandardErrorOfEstimate();
                    }
                    else {
                        a = analysisResults.getMonthlyEquationRegressionResults(month).getA();
                        b = analysisResults.getMonthlyEquationRegressionResults(month).getB();
                        r = analysisResults.getMonthlyEquationRegressionResults(month).getCorrelationCoefficient();
                        n1 = analysisData.getMonthlyEquationRegressionData(month).getN1();
                        xbar = analysisData.getMonthlyEquationRegressionData(month).getMeanX1();
                        var = Math.pow(analysisData.getMonthlyEquationRegressionData(month).getStandardDeviationX1(), 2);
                        see = errors.getMonthlyEquationRegressionErrors(month).getStandardErrorOfEstimate();
                    }
                    newval = a + b*x;

                    if ( Message.isDebugOn ) {
                        Message.printDebug ( dl, routine, "Calculated dependent value a + b*x=" +
                            a + "+" + b + "*" + x + "=" + newval );
                    }

                    if ( transformation == DataTransformationType.LOG ) {
                        // Now convert Y back from log10 space...
                        if ( Message.isDebugOn ) {
                            Message.printDebug ( dl, routine, "Calculated untransformed dependent value pow(10," +
                                newval + ")=" + Math.pow(10.0,newval) );
                        }
                        newval = Math.pow(10.0,newval);
                    }


                    if (__bestFit == BestFitIndicatorType.SEP) {
                    	Double newSEP = see*Math.sqrt(1+(1.0/n1)+(Math.pow((x - xbar),2)/(n1*var)));
                    	newSEP *= 2.3026; //not sure why we're doing this, but it is in the older program
                    	
                    	//consistent comparisons between transformed and untransformed....
                    	if (transformation == DataTransformationType.NONE && newSEP != 0) {
                    		newSEP = Math.log10(newSEP);
                    	}

                    	//SEP has to exist and be smaller than a certain size....
                    	if (newSEP != null && newSEP != Double.NaN && (newSEP*newSEP - 1) <= 10 && (Math.exp(newSEP*newSEP) - 1) >= 0) {
                    		//get percentage error, not raw error
                    		newSEP = 100*Math.sqrt(Math.exp(newSEP*newSEP) - 1);
                    		if (newSEP != null && newSEP != Double.NaN && newSEP <= SEP ) {
                    			SEP = newSEP;
                    		}
                    		else {
                    			//this value is worse than previous, don't fill, just keep going....
                    			continue;
                    		}
                    	}
                    	else {
                    		//SEP wasn't OK, go around and try again
                    		Message.printStatus(2, routine, "SEP unacceptably high: "+newSEP);
                    		continue;
                    	}
                    }
                    else if (__bestFit == BestFitIndicatorType.R) {
                    	if (r >= R) {
                    		R = r;
                    	}
                    	else {
                    		//new r worse than old, go around and try again
                    		continue;
                    	}
                    }

                    //fill with this one....
                    //we're assuming that if it shouldn't be filled, this code won't be called in the first place
                    if ( fillFlag_boolean ) {

                    	String fillFlag2 = fillFlag;
                    	if ( (fillFlag != null) && fillFlag.equalsIgnoreCase("auto") ) {
                    		// Use the found relationship for the fill flag
                    		int equations;
                    		if (fillSingle) equations = 1;
                    		else equations = 12;
                    		//with how we're sorting, always filling with best available
                    		fillFlag2 = determineFillFlag(equations, month, 1);
                    	}
                    	else if (fillFlag.equalsIgnoreCase("i")) {
                    		//note which time series exactly is being used to fill
                    		if (fillSingle) {
                    			fillFlag2 = ""+analysis.getIndependentTS().getLocation();
                    		}
                    		else {
                    			fillFlag2 = TimeUtil.monthAbbreviation(month)+analysis.getIndependentTS().getLocation();
                    		}
                    	}
                    	// Set the flag...
                    	tsToFill.setDataValue ( date, newval, fillFlag2, 1 );
                    }
                    else {
                    	// No flag...
                    	tsToFill.setDataValue ( date, newval );
                    }

                    // Increment the counter on the number of values filled
                    if ( fillSingle ) {
                    	singleEquationFilledValues[fillCountSingle] = newval;
                    	if (firstTime) {
                    		firstTime = false;
                    		++fillCountSingle;
                    	}
                    }
                    else {
                    	monthlyEquationFilledValues[month - 1][fillCountMonthly[month - 1]] = newval;
                    	if (firstTime) {
                    		firstTime = false;
                    		++fillCountMonthly[month - 1];
                    	}
                    }
                    
                    
                 // Fill in the genesis information...

                    if ( fillCountSingle > 0 ) {
                        tsToFill.addToGenesis ( "Filled " + fillCountSingle + " missing values " + fillStart + " to " + fillEnd + " using analysis results:" );
                    
                        // The following comes back as multiple strings but to handle genesis
                        // information nicely, break into separate strings...
                    
                        List<String> strings = StringUtil.breakStringList ( analysis.toString(),
                            System.getProperty("line.separator"), StringUtil.DELIM_SKIP_BLANKS );
                        for ( String string : strings ) {
                            tsToFill.addToGenesis( string );
                        }

                        String descriptionString = getDescriptionString();
                        if ( descriptionString != null ) {
                            // Description has been specified...
                            tsToFill.setDescription ( tsToFill.getDescription() + descriptionString );
                        }
                        else {
                            // Automatically add to the description...
                        	String monthString = "";
                        	if (analysis.getAnalyzeMonthlyEquations()) {
                        		monthString = " monthly";
                        	}
                            if ( (__analysisMonths != null) && (__analysisMonths.length == 1) ) {
                                // Filling one month so be specific in the description
                                monthString = " " + TimeUtil.monthAbbreviation(__analysisMonths[0]);
                            }
                            if ( transformation == DataTransformationType.LOG ) {
                            	if (!tsToFill.getDescription().contains(tsIndependent.getIdentifierString())) {
                            		//if it's already been set, don't set it again
                            		tsToFill.setDescription ( tsToFill.getDescription()+
                            			", fill log " + __analysisMethod + monthString + " using " + tsIndependent.getIdentifierString() );
                            	}
                            }
                            else {
                            	if (!tsToFill.getDescription().contains(tsIndependent.getAlias())) {
                            		//if it's already been set, don't set it again
                            		tsToFill.setDescription ( tsToFill.getDescription() +
                            			", fill " + __analysisMethod + monthString + " using " + tsIndependent.getAlias());
                            	}
                            }
                        }
                    }
                    if (fillCountMonthly[month - 1] > 0) {
                    	tsToFill.addToGenesis ( "Filled " + fillCountMonthly[month - 1] + " missing values " + fillStart + " to " + fillEnd + " using analysis results:" );
                        
                        // The following comes back as multiple strings but to handle genesis
                        // information nicely, break into separate strings...
                    
                        List<String> strings = StringUtil.breakStringList ( analysis.toString(),
                            System.getProperty("line.separator"), StringUtil.DELIM_SKIP_BLANKS );
                        for ( String string : strings ) {
                            tsToFill.addToGenesis( string );
                        }

                        String descriptionString = getDescriptionString();
                        if ( descriptionString != null ) {
                            // Description has been specified...
                            tsToFill.setDescription ( tsToFill.getDescription() + descriptionString );
                        }
                        else {
                            // Automatically add to the description...
                        	String monthString = "";
                        	if (analysis.getAnalyzeMonthlyEquations()) {
                        		monthString = " monthly";
                        	}
                            if ( (__analysisMonths != null) && (__analysisMonths.length == 1) ) {
                                // Filling one month so be specific in the description
                                monthString = " " + TimeUtil.monthAbbreviation(__analysisMonths[0]);
                            }
                            if ( transformation == DataTransformationType.LOG ) {
                            	if (!tsToFill.getDescription().contains(tsIndependent.getIdentifierString())) {
                            		//if it's already been set, don't set it again
                            		tsToFill.setDescription ( tsToFill.getDescription()+
                            			", fill log " + __analysisMethod + monthString + " using " + tsIndependent.getIdentifierString() );
                            	}
                            }
                            else {
                            	if (!tsToFill.getDescription().contains(tsIndependent.getAlias())) {
                            		//if it's already been set, don't set it again
                            		tsToFill.setDescription ( tsToFill.getDescription() +
                            			", fill " + __analysisMethod + monthString + " using " + tsIndependent.getAlias());
                            	}
                            }
                        }
                    }
            	}
            }
        }
        catch ( Exception e ) {
            // Error filling interval - this likely is a logic or error-handling issue and needs
            // to be resolved
            problems.add ( "Error filling value at " + date + " (" + e + ")." );
            if ( errorCount++ < 100 ) {
                Message.printWarning ( 3, routine, e );
            }
        }
    }

    // TODO SAM 2012-05-21 Figure out what to do with transformed values
    // Set the filled values arrays.  Resize based on the actual number of filled values.
    double [] singleEquationFilledValues2 = new double[0];
    double [][] monthlyEquationFilledValues2 = new double[12][0];
    RegressionFilledValues [] monthlyRegressionFilledValues = new RegressionFilledValues[12];
    singleEquationFilledValues2 = new double[fillCountSingle];
    System.arraycopy(singleEquationFilledValues, 0, singleEquationFilledValues2, 0, fillCountSingle);
    for ( int i = 0; i < 12; i++ ) {
    	monthlyEquationFilledValues2[i] = new double[fillCountMonthly[i]];
    	System.arraycopy(monthlyEquationFilledValues[i], 0, monthlyEquationFilledValues2[i], 0, fillCountMonthly[i]);
    	monthlyRegressionFilledValues[i] = new RegressionFilledValues(monthlyEquationFilledValues2[i]);
    }
    setTSRegressionFilledValues( new TSRegressionFilledValues(tsToFill,
    	new RegressionFilledValues(singleEquationFilledValues2), monthlyRegressionFilledValues));
}

/**
Return the analysis method.
@return the analysis method.
*/
private RegressionType getAnalysisMethod ()
{
    return __analysisMethod;
}

/**
Return an array indicating the months to be analyzed, each value 1-12.  This information
corresponds to the AnalysisMonth property that is passed in at construction.
@return the array containing the months (1-12) to be analyzed, or null if all months will be analyzed.
*/
public int [] getAnalysisMonths ()
{   return __analysisMonths;
}

/**
Return the dependent time series analysis end.
@return the dependent time series analysis end.
*/
public DateTime getDependentAnalysisEnd()
{   return __dependentAnalysisEnd;
}

/**
Return the dependent time series analysis start.
@return the dependent time series analysis start.
*/
public DateTime getDependentAnalysisStart()
{   return __dependentAnalysisStart;
}

/**
Return the description string.
*/
public String getDescriptionString ()
{
    return __descriptionString;
}

/**
Return whether to fill.
@return whether to fill.
*/
public boolean getDoFill()
{   return __doFill;
}

/**
Return the fill end.
@return the fill end.
*/
public DateTime getFillEnd()
{   return __fillEnd;
}

/**
Return the fill flag.
@return the fill flag
*/
public String getFillFlag ()
{
    return __fillFlag;
}

/**
Return the fill flag description.
@return the fill flag description
*/
public String getFillFlagDesc ()
{
    return __fillFlagDesc;
}

/**
Return the independent time series analysis start.
@return the independent time series analysis start.
*/
public DateTime getFillStart()
{   return __fillStart;
}

/**
Return the forced intercept.
@return the forced intercept.
*/
public Double getForcedIntercept ()
{   return __forcedIntercept;
}

/**
Return the independent time series analysis end.
@return the independent time series analysis end.
*/
public DateTime getIndependentAnalysisEnd()
{   return __independentAnalysisEnd;
}

/**
Return the independent time series analysis start.
@return the independent time series analysis start.
*/
public DateTime getIndependentAnalysisStart()
{   return __independentAnalysisStart;
}

/**
Return the value that will be used for the log transform if the original is <= 0.
@return the value that will be used for the log transform if the original is <= 0.
*/
private double getLEZeroLogValue ()
{   
	return __leZeroLogValue;
}

/**
Return the minimum acceptable R - if null then R is not checked.
@return the minimum acceptable R.
*/
public Double getMinimumR ()
{   return __minimumR;
}

/**
Return the minimum acceptable sample size - if null then sample size is not checked.
@return the minimum acceptable sample size.
*/
public Integer getMinimumSampleSize ()
{   return __minimumSampleSize;
}

/**
Indicate whether the analysis is performed using one equation or monthly equations.
@return the number of equations used for the analysis.
*/
public NumberOfEquationsType getNumberOfEquations( )
{   return __numberOfEquations;
}

/**
Return a list of problems for the time series.
@return a list of problems for the time series
*/
public List<String> getProblems ()
{
    return __problems;
}

/**
Return the TSRegressionFilledValues object.
@return the TSRegressionFilledValues object.
*/
public TSRegressionFilledValues getTSRegressionFilledValues ()
{
    return __tsRegressionFilledValues;
}

/**
Return the time series to fill (Y).
@return the time series to fill (Y).
*/
public TS getTSToFill()
{   return __tsToFill;
}

/**
Save the statistics from the regression analysis to a table object.
@param ts dependent time series
@param table the table to save the results
@param tableTSIDColumnName the name of the table column containing the TSID/alias to match
@param tableTSIDFormat the format string for the time series - to allow matching the contents of the
tableTSIDColumnName
@param regressionType the regression type, which will impact formatting of results (independent analysis period
is specific to MOVE2)
@param numberOfEquations the number of equations in the analysis, which will impact the number of columns
in the output (whether or not monthly statistics are shown)
*/
public void saveStatisticsToTable ( TS ts, DataTable table,
    String tableTSIDColumnName, String tableTSIDFormat, RegressionType regressionType,
    NumberOfEquationsType numberOfEquations
    //,boolean includeRaw, boolean includeTransformed
    )
throws Exception
{   
	String routine = getClass().getName() + ".saveStatisticsToTable";
    // Verify that the TSID table columns are available for dependent and independent time series
    String tableTSIDColumnNameIndependent = tableTSIDColumnName + "_Independent";
    int tableTSIDColumnNumber = -1;
    int tableTSIDColumnNumberIndependent = -1;
    // If the TSID column name does not exist, add it to the table
    try {
        tableTSIDColumnNumber = table.getFieldIndex(tableTSIDColumnName);
    }
    catch ( Exception e2 ) {
        // Automatically add to the table, initialize with null (not nonValue)
        table.addField(new TableField(TableField.DATA_TYPE_STRING,tableTSIDColumnName,-1,-1), null );
        // Get the corresponding column number for row-edits below
        tableTSIDColumnNumber = table.getFieldIndex(tableTSIDColumnName);
        // Set the description, which is used as the tool tip in the UI
        table.getTableField(tableTSIDColumnNumber).setDescription("Dependent time series identifier");
    }
    // If the TSID_Independent column does not exist, add it to the table
    try {
        tableTSIDColumnNumberIndependent = table.getFieldIndex(tableTSIDColumnNameIndependent);
    }
    catch ( Exception e2 ) {
        // Automatically add to the table, initialize with null (not nonValue)
        table.addField(new TableField(TableField.DATA_TYPE_STRING,tableTSIDColumnNameIndependent,-1,-1), null );
        // Get the corresponding column number for row-edits below
        tableTSIDColumnNumberIndependent = table.getFieldIndex(tableTSIDColumnNameIndependent);
        // Set the description, which is used as the tool tip in the UI
        table.getTableField(tableTSIDColumnNumberIndependent).setDescription("Independent time series identifier");
    }
    // Add additional generic columns, for informational purposes - put these here to avoid
    // duplication for each month if monthly analysis
    List<String> columnsToAdd = new Vector<String>();
    List<String> descriptionsToAdd = new Vector<String>();
    columnsToAdd.add ( "AnalysisMethod" );
    descriptionsToAdd.add ( "Regression analysis method (Ordinary Least Squares or Maintenance of Variation 2)" );
    columnsToAdd.add ( "DependentAnalysisStart" );
    descriptionsToAdd.add ( "Dependent time series analysis period start, used to determine relationships" );
    columnsToAdd.add ( "DependentAnalysisEnd" );
    descriptionsToAdd.add ( "Dependent time series analysis period end, used to determine relationships" );
    // TODO SAM 2012-05-24 Evaluate whether the following 2 are confusing for normal OLS regression
    columnsToAdd.add ( "IndependentAnalysisStart" );
    columnsToAdd.add ( "IndependentAnalysisEnd" );
    if ( regressionType == RegressionType.OLS_REGRESSION ) {
        descriptionsToAdd.add ( "Independent time series analysis period start (same as DependentAnalysisStart for OLS regression), used to determine relationships" );
        descriptionsToAdd.add ( "Independent time series analysis period end (same as DependentAnalysisStart for OLS regression), used to determine relationships" );
    }
    else if ( regressionType == RegressionType.MOVE2 ) {
        descriptionsToAdd.add ( "Independent time series analysis period start, used to determine relationships" );
        descriptionsToAdd.add ( "Independent time series analysis period end, used to determine relationships" );
    }
    else {
        descriptionsToAdd.add ( "" );
        descriptionsToAdd.add ( "" );
    }
    columnsToAdd.add ( "FillStart" );
    descriptionsToAdd.add ( "Fill period start" );
    columnsToAdd.add ( "FillEnd" );
    descriptionsToAdd.add ( "Fill period end" );
    columnsToAdd.add ( "Transformation" );
    descriptionsToAdd.add ( "Transformation performed on data prior to determining relationship" );
    columnsToAdd.add ( "MinimumSampleSize" );
    descriptionsToAdd.add ( "Minimum sample size (N1) to consider the relationship valid" );
    columnsToAdd.add ( "MinimumR" );
    descriptionsToAdd.add ( "Minimum R to consider the relationship valid" );
    columnsToAdd.add ( "ConfidenceInterval" );
    descriptionsToAdd.add ( "Confidence interval (%) required for relationship line slope" );
    for ( int i = 0; i < columnsToAdd.size(); i++ ) {
        try {
            // See if column is already in the table
            table.getFieldIndex(columnsToAdd.get(i));
        }
        catch ( Exception e2 ) {
            // Automatically add to the table, initialize with null (not nonValue)
            if ( columnsToAdd.get(i).equalsIgnoreCase("ConfidenceInterval") ||
                columnsToAdd.get(i).equalsIgnoreCase("MinimumR")) {
                // Floating point
                table.addField(new TableField(
                    TableField.DATA_TYPE_DOUBLE,columnsToAdd.get(i),-1,8), null );
            }
            else if ( columnsToAdd.get(i).equalsIgnoreCase("MinimumSampleSize") ) {
                // Integer
                table.addField(new TableField(
                    TableField.DATA_TYPE_INT,columnsToAdd.get(i),-1,-1), null );
            }
            else {
                // Rest are strings
                table.addField(new TableField(TableField.DATA_TYPE_STRING,columnsToAdd.get(i),-1,-1), null );
            }
            // Set the description, which is used as the tool tip in the UI
            table.getTableField(table.getFieldIndex(columnsToAdd.get(i))).setDescription(descriptionsToAdd.get(i));
        }
    }
    // Loop through the statistics, creating table column names if necessary
    // Do this first so that all columns are fully defined.  Then process the row values below.
    int numEquations = 1;
    if ( numberOfEquations == NumberOfEquationsType.MONTHLY_EQUATIONS ) {
        numEquations = 12;
    }
    // List in a reasonable order - see the command documentation for more
    // X=independent
    // Y=dependent
    List<String> statsToOutput = new Vector<String>();
    // Statistics that have _trans are for transformed data and will only be output if a transformation
    // has been specified
    // _trans means in units of log10(original units), therefore unitless quantities will not have _trans tags
    // mean, standard deviation, etc. probably aren't needed by end user, but are helpful along the way, so they'll be outputted for now
    
    //need to get statistics from every combination
    for (TSRegressionAnalysis analysis : __tsRegressionAnalysisList) {
    	DataTransformationType transformation = analysis.getTransformation();
    	// Statistics from the input data...
    	statsToOutput.add ( "N1" ); // Same for raw and transformed
    	statsToOutput.add ( "MeanX1" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "MeanX1_trans" );
    	}
    	statsToOutput.add ( "SX1" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "SX1_trans" );
    	}
    	statsToOutput.add ( "N2" );
    	statsToOutput.add ( "MeanX2" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "MeanX2_trans" );
    	}
    	statsToOutput.add ( "SX2" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "SX2_trans" );
    	}
    	statsToOutput.add ( "MeanY1" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "MeanY1_trans" );
    	}
    	statsToOutput.add ( "SY1" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "SY1_trans" );
    	}
    	statsToOutput.add ( "NY" );
    	statsToOutput.add ( "MeanY" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "MeanY_trans" );
    	}
    	statsToOutput.add ( "SY" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "SY_trans" );
    	};
    	statsToOutput.add ( "SkewY" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "SkewY_trans" );
    	};
    	// Statistics from the analysis results...
    	if ( transformation == DataTransformationType.NONE ) {
    		statsToOutput.add ( "a" );
    		statsToOutput.add ( "b" );
    		statsToOutput.add ( "R" );
    		statsToOutput.add ( "R2" );
    	}
    	else {
    		statsToOutput.add ( "a_trans" );
    		statsToOutput.add ( "b_trans" );
    		//does R really have units?
    		statsToOutput.add ( "R_trans" );
    		statsToOutput.add ( "R2_trans" );
    	}
    	// Statistics from the error estimates...
    	statsToOutput.add ( "MeanY1est" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "MeanY1est_trans" );
    	}
    	statsToOutput.add ( "SY1est" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "SY1est_trans" );
    	}
    	statsToOutput.add ( "RMSE" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "RMSE_trans" );
    	}
    	statsToOutput.add ( "SEE" );
    	if ( transformation != DataTransformationType.NONE ) {
    		statsToOutput.add ( "SEE_trans" );
    	}

    	//unitless quantities don't have _trans variants
    	statsToOutput.add ( "SESlope" );
    	statsToOutput.add ( "TestScore" );
    	statsToOutput.add ( "TestQuantile" );
    	statsToOutput.add ( "TestOK" );
    	statsToOutput.add ( "SampleSizeOK" );
    	statsToOutput.add ( "ROK" );

    	// Statistics from the filled data, always in data space
    	// (include for comparison with mixed station analysis)...
    	statsToOutput.add ( "NYfilled" );
    	statsToOutput.add ( "MeanYfilled" );
    	statsToOutput.add ( "SYfilled" );
    	statsToOutput.add ( "SkewYfilled" );

    	// The following comments parallel the statistics names are used to create comments in the table header
    	String [] mainComments = {
    			"",
    			"The following statistics are computed to determine and evaluate the the regression relationships.",
    			"The regression type performed was:  " + getAnalysisMethod(),
    			"X indicates the independent time series and Y indicates the dependent time series.",
    			"Some statistics are ignored for some regression approaches, but are provided for comparison.",
    			""
    	};
    	String [] mainCommentsMonthly = {
    			"",
    			"Monthly statistics (for case where NumberOfEquations=MonthlyEquatations) will have a _M subscript, " +
    			"where M is the month (1=January, 12=December).",
    			""
    	};
    	HashMap<String,String> statisticComments = new HashMap<String,String>();
    	statisticComments.put("N1","Count of non-missing data points overlapping in the dependent and independent time series in the analysis period");
    	statisticComments.put("MeanX1","Mean of the independent N1 values");
    	statisticComments.put("SX1","Standard deviation of the independent N1 values");
    	statisticComments.put("N2","Count of the non-missing data points in the independent time series outside of N1 in the analysis period");
    	statisticComments.put("MeanX2","Mean of the independent N2 values");
    	statisticComments.put("SX2","Standard deviation of the independent N2 values");
    	statisticComments.put("MeanY1","Mean of the dependent N1 values");
    	statisticComments.put("SY1","Standard deviation of the dependent N1 values");
    	statisticComments.put("NY","Count of the non-missing dependent values in the analysis period");
    	statisticComments.put("MeanY","Mean of the NY dependent values in the analysis period");
    	statisticComments.put("SY","Standard deviation of the NY dependent values in the analysis period");
    	statisticComments.put("a","The intercept for the relationship equation");
    	statisticComments.put("b","The slope of the relationship equation");
    	statisticComments.put("R","The correlation coefficient for N1 values");
    	statisticComments.put("R2","R-squared, coefficient of determination for N1 values");
    	statisticComments.put("MeanY1est",
    	"Mean of N1 values computed from the relationship (estimate dependent N1 values where previously known)");
    	statisticComments.put("SY1est",
    	"Standard deviation of N1 values computed from the relationship (estimate dependent N1 values where previously known");
    	statisticComments.put("RMSE","Root mean squared error for N1 values, computed from regression relationship estimated values");
    	statisticComments.put("SEE","Standard error of estimate for N1 values, computed from regression relationship estimated values");
    	statisticComments.put("SEP","Standard error of prediction for N1 values, computed from regression relationship estimated values");
    	statisticComments.put("SEslope","Standard error (SE) of the slope (b) for N1 values, computed from regression relationship estimated values");
    	statisticComments.put("TestScore","b/SE");
    	statisticComments.put("TestQuantile","From the Student's T-test, function of confidence interval and degrees of freedom, DF (N1 - 2)");
    	statisticComments.put("TestOK","Yes if TestScore >= TestQuantile, No if otherwise");
    	statisticComments.put("SampleSizeOK","Yes if sample size >= minimum sample size, No if otherwise");
    	statisticComments.put("ROK","Yes if R >= minimum R, No if otherwise");
    	// Put these in for comparison with mixed station analysis
    	statisticComments.put("NYfilled","Number of dependent values filled in the fill period");
    	statisticComments.put("MeanYfilled","Mean of the filled values");
    	statisticComments.put("SYfilled","Standard deviation of the filled values");
    	statisticComments.put("SkewYfilled","Skew of the filled values");
    	// Add comments to the table header
    	table.addToComments(Arrays.asList(mainComments));
    	if ( numberOfEquations == NumberOfEquationsType.MONTHLY_EQUATIONS ) {
    		table.addToComments(Arrays.asList(mainCommentsMonthly));
    	}
    	// FIXME SAM 2012-01-16 Need to add statistics comments
    	//int i = 0;
    	//for ( String comment: statisticComments ) {
    	//    table.addToComments(statistics[i++] + " - " + comment);
    	//}
    	table.addToComments ( "" );
    	int countStatisticTotal = statsToOutput.size()*numEquations; // The total number of statistics columns to add
    	String [] statisticColumnNames = new String[countStatisticTotal]; // names in table
    	int [] statisticFieldType = new int[countStatisticTotal]; // value types
    	// Arrays for the statistics.  Using multiple arrays will result in some statistic
    	// values being null; however this is easier than dealing with casts later in the code
    	Double [] statisticValueDouble = new Double[countStatisticTotal];
    	Integer [] statisticValueInteger = new Integer[countStatisticTotal];
    	String [] statisticValueString = new String[countStatisticTotal];

    	// The count of statistics added (0-index), necessary because when dealing with monthly statistics
    	// the 12 months are flattened into a linear array matching column headings
    	//needs to be reset every analysis cycle...
    	int countStatistic = -1;
    	
    	// Get the main sub-objects associated with the analysis
    	TSRegressionData tsRegressionData = analysis.getTSRegressionData();
    	TSRegressionData tsRegressionDataTransformed = analysis.getTSRegressionDataTransformed();
    	TSRegressionResults tsRegressionResults = analysis.getTSRegressionResults();
    	TSRegressionResults tsRegressionResultsTransformed = analysis.getTSRegressionResultsTransformed();
    	TSRegressionEstimateErrors tsRegressionEstimateErrors = analysis.getTSRegressionEstimateErrors();
    	TSRegressionEstimateErrors tsRegressionEstimateErrorsTransformed = analysis.getTSRegressionErrorsTransformed();
    	TSRegressionChecks tsRegressionChecks = analysis.getTSRegressionChecksTransformed();
    	TSRegressionFilledValues tsRegressionFilledValues = getTSRegressionFilledValues();
    	String statisticName; // Statistic to output
    	for ( int iEquation = 1; iEquation <= numEquations; iEquation++ ) {
    		for ( int iStatistic = 0; iStatistic < statsToOutput.size(); iStatistic++ ) {
    			statisticName = statsToOutput.get(iStatistic);
    			try {
    				// Set statistics to null (one will be set below).
    				++countStatistic;
    				statisticValueDouble[countStatistic] = null;
    				statisticValueInteger[countStatistic] = null;
    				// Column name for the statistic (list alphabetically)...
    				if ( numEquations == 1 ) {
    					statisticColumnNames[countStatistic] = statisticName;
    				}
    				else {
    					statisticColumnNames[countStatistic] = statisticName + "_" + iEquation;
    				}
    				//these are essentially a switch statement, grabbing the right statistic based on the name
    				//TODO 7-29-2013: Java 7 can use a switch statement for strings
    				//so when that switch is done, this should be changed!
    				if ( statisticName.equals("a") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResults.getSingleEquationRegressionResults().getA();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getA();
    					}
    				}
    				else if ( statisticName.equals("AnalysisStart") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResults.getSingleEquationRegressionResults().getA();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getA();
    					}
    				}
    				else if ( statisticName.equals("a_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResultsTransformed.getSingleEquationRegressionResults().getA();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResultsTransformed.getMonthlyEquationRegressionResults(iEquation).getA();
    					}
    				}
    				else if ( statisticName.equals("b") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResults.getSingleEquationRegressionResults().getB();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getB();
    					}
    				}
    				else if ( statisticName.equals("b_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResultsTransformed.getSingleEquationRegressionResults().getB();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResultsTransformed.getMonthlyEquationRegressionResults(iEquation).getB();
    					}
    				}
    				else if ( statisticName.equals("MeanX") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getMeanX();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getMeanX();
    					}
    				}
    				else if ( statisticName.equals("MeanX1") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getMeanX1();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getMeanX1();
    					}
    				}
    				else if ( statisticName.equals("MeanX1_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getSingleEquationRegressionData().getMeanX1();
    					}
    					else {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getMonthlyEquationRegressionData(iEquation).getMeanX1();
    					}
    				}
    				else if ( statisticName.equals("MeanX2") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						if (tsRegressionData.getSingleEquationRegressionData().getN2() == 0) {
    							statisticValueDouble[countStatistic] = null;
    						}
    						else {
    							statisticValueDouble[countStatistic] =
    								tsRegressionData.getSingleEquationRegressionData().getMeanX2();
    						}
    					}
    					else {
    						if (tsRegressionData.getMonthlyEquationRegressionData(iEquation).getN2() == 0) {
    							statisticValueDouble[countStatistic] = null;
    						}
    						else {
    							statisticValueDouble[countStatistic] =
    								tsRegressionData.getMonthlyEquationRegressionData(iEquation).getMeanX2();
    						}
    					}
    				}
    				else if ( statisticName.equals("MeanX2_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						if (tsRegressionDataTransformed.getSingleEquationRegressionData().getN2() == 0) {
    							statisticValueDouble[countStatistic] = null;
    						}
    						else {
    							statisticValueDouble[countStatistic] =
    								tsRegressionDataTransformed.getSingleEquationRegressionData().getMeanX2();
    						}
    					}
    					else {
    						if (tsRegressionDataTransformed.getMonthlyEquationRegressionData(iEquation).getN2() == 0) {
    							statisticValueDouble[countStatistic] = null;
    						}
    						else {
    							statisticValueDouble[countStatistic] =
    								tsRegressionDataTransformed.getMonthlyEquationRegressionData(iEquation).getMeanX2();
    						}
    					}
    				}
    				else if ( statisticName.equals("MeanY") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getMeanY();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getMeanY();
    					}
    				}
    				else if ( statisticName.equals("MeanY_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getSingleEquationRegressionData().getMeanY();
    					}
    					else {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getMonthlyEquationRegressionData(iEquation).getMeanY();
    					}
    				}
    				else if ( statisticName.equals("MeanYfilled") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionFilledValues.getSingleEquationRegressionFilledValues().getMeanYFilled();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionFilledValues.getMonthlyEquationRegressionFilledValues(iEquation).getMeanYFilled();
    					}
    				}
    				else if ( statisticName.equals("MeanY1") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getMeanY1();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getMeanY1();
    					}
    				}
    				else if ( statisticName.equals("MeanY1_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getSingleEquationRegressionData().getMeanY1();
    					}
    					else {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getMonthlyEquationRegressionData(iEquation).getMeanY1();
    					}
    				}
    				else if ( statisticName.equals("MeanY1est") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getMeanY1est();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getMeanY1est();
    					}
    				}
    				else if ( statisticName.equals("MeanY1est_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionEstimateErrorsTransformed.getSingleEquationRegressionErrors().getMeanY1est();
    					}
    					else {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionEstimateErrorsTransformed.getMonthlyEquationRegressionErrors(iEquation).getMeanY1est();
    					}
    				}
    				else if ( statisticName.equals("NX") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
    					if ( numEquations == 1 ) {
    						statisticValueInteger[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getN();
    					}
    					else {
    						statisticValueInteger[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getN();
    					}
    				}
    				else if ( statisticName.equals("N1") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
    					if ( numEquations == 1 ) {
    						statisticValueInteger[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getN1();
    					}
    					else {
    						statisticValueInteger[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getN1();
    					}
    				}
    				else if ( statisticName.equals("N2") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
    					if ( numEquations == 1 ) {
    						statisticValueInteger[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getN2();
    					}
    					else {
    						statisticValueInteger[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getN2();
    					}
    				}
    				else if ( statisticName.equals("NY") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
    					if ( numEquations == 1 ) {
    						statisticValueInteger[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getNY();
    					}
    					else {
    						statisticValueInteger[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getNY();
    					}
    				}
    				else if ( statisticName.equals("NYfilled") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
    					if ( numEquations == 1 ) {
    						statisticValueInteger[countStatistic] =
    							tsRegressionFilledValues.getSingleEquationRegressionFilledValues().getNFilled();
    					}
    					else {
    						statisticValueInteger[countStatistic] =
    							tsRegressionFilledValues.getMonthlyEquationRegressionFilledValues(iEquation).getNFilled();
    					}
    				}
    				else if ( statisticName.equals("R") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResults.getSingleEquationRegressionResults().getCorrelationCoefficient();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getCorrelationCoefficient();
    					}
    				}
    				else if ( statisticName.equals("R_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionResultsTransformed.getSingleEquationRegressionResults().getCorrelationCoefficient();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionResultsTransformed.getMonthlyEquationRegressionResults(iEquation).getCorrelationCoefficient();
    					}
    				}
    				else if ( statisticName.equals("R2") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					Double r = null;
    					if (numEquations == 1 ) {
    						r = tsRegressionResults.getSingleEquationRegressionResults().getCorrelationCoefficient();
    					}
    					else {
    						r = tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getCorrelationCoefficient();
    					}
    					if (r != null) {
    						Double r2 = new Double(r*r);
    						statisticValueDouble[countStatistic] = r2;
    					}
    					else {
    						statisticValueDouble[countStatistic] = null;
    					}
    				}
    				else if ( statisticName.equals("R2_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					Double r = null;
    					if (numEquations == 1) {
    						r = tsRegressionResultsTransformed.getSingleEquationRegressionResults().getCorrelationCoefficient();
    					}
    					else {
    						r = tsRegressionResultsTransformed.getMonthlyEquationRegressionResults(iEquation).getCorrelationCoefficient();
    					}
    					if (r != null) {
    						Double r2 = new Double(r*r);
    						statisticValueDouble[countStatistic] = r2;
    					}
    					else {
    						statisticValueDouble[countStatistic] = null;
    					}
    				}
    				else if ( statisticName.equals("RMSE") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getRMSE();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getRMSE();
    					}
    				}
    				else if ( statisticName.equals("RMSE_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionEstimateErrorsTransformed.getSingleEquationRegressionErrors().getRMSE();
    					}
    					else {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionEstimateErrorsTransformed.getMonthlyEquationRegressionErrors(iEquation).getRMSE();
    					}
    				}
    				else if ( statisticName.equals("ROK") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_STRING;
    					// Only have a value if the minimum R has been specified
    					if ( getMinimumR() == null ) {
    						statisticValueString[countStatistic] = "";
    					}
    					else {
    						boolean rok = tsRegressionChecks.getSingleEquationRegressionChecks().getIsROK();
    						if ( numEquations == 12 ) {
    							rok = tsRegressionChecks.getMonthlyEquationRegressionChecks(iEquation).getIsROK();
    						}
    						if ( rok ) {
    							statisticValueString[countStatistic] = "Yes";
    						}
    						else {
    							statisticValueString[countStatistic] = "No";
    						}
    					}
    				}
    				else if ( statisticName.equals("SampleSizeOK") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_STRING;
    					// Minimum sample size will always be specified internally so always show
    					Boolean ssOk = null;
    					if ( numEquations == 1) {
    						ssOk = tsRegressionChecks.getSingleEquationRegressionChecks().getIsSampleSizeOK();
    					}
    					if ( numEquations == 12 ) {
    						ssOk = tsRegressionChecks.getMonthlyEquationRegressionChecks(iEquation).getIsSampleSizeOK();
    					}
    					if ( ssOk ) {
    						statisticValueString[countStatistic] = "Yes";
    					}
    					else {
    						statisticValueString[countStatistic] = "No";
    					}
    				}
    				else if ( statisticName.equals("SEE") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getStandardErrorOfEstimate();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getStandardErrorOfEstimate();
    					}
    				}
    				else if ( statisticName.equals("SEE_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionEstimateErrorsTransformed.getSingleEquationRegressionErrors().getStandardErrorOfEstimate();
    					}
    					else {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionEstimateErrorsTransformed.getMonthlyEquationRegressionErrors(iEquation).getStandardErrorOfEstimate();
    					}
    				}
    				else if ( statisticName.equals("SESlope") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getStandardErrorOfSlope();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getStandardErrorOfSlope();
    					}
    				}
    				/*
                else if ( statisticName.equals("SX") ) {
                    statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationX());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationX(iEquation));
                    }
                }*/
    				else if ( statisticName.equals("SkewY") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getSkewY();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getSkewY();
    					}
    				}
    				else if ( statisticName.equals("SkewY_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getSingleEquationRegressionData().getSkewY();
    					}
    					else {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getMonthlyEquationRegressionData(iEquation).getSkewY();
    					}
    				}
    				else if ( statisticName.equals("SkewYfilled") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionFilledValues.getSingleEquationRegressionFilledValues().getSkewYFilled();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionFilledValues.getMonthlyEquationRegressionFilledValues(iEquation).getSkewYFilled();
    					}
    				}
    				else if ( statisticName.equals("SX1") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getStandardDeviationX1();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getStandardDeviationX1();
    					}
    				}
    				else if ( statisticName.equals("SX1_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getSingleEquationRegressionData().getStandardDeviationX1();
    					}
    					else {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getMonthlyEquationRegressionData(iEquation).getStandardDeviationX1();
    					}
    				}
    				else if ( statisticName.equals("SX2") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						if (tsRegressionData.getSingleEquationRegressionData().getN2() == 0) {
    							statisticValueDouble[countStatistic] = null;
    						}
    						else {
    							statisticValueDouble[countStatistic] =
    								tsRegressionData.getSingleEquationRegressionData().getStandardDeviationX2();
    						}
    					}
    					else {
    						if ((tsRegressionData.getMonthlyEquationRegressionData(iEquation).getN2() == 0)) {
    							statisticValueDouble[countStatistic] = null;
    						}
    						else {
    							statisticValueDouble[countStatistic] = 
    								tsRegressionData.getMonthlyEquationRegressionData(iEquation).getStandardDeviationX2();
    						}
    					}
    				}
    				else if ( statisticName.equals("SX2_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						if (tsRegressionDataTransformed.getSingleEquationRegressionData().getN2() == 0) {
    							statisticValueDouble[countStatistic] = null;
    						}
    						else {
    							statisticValueDouble[countStatistic] =
    								tsRegressionDataTransformed.getSingleEquationRegressionData().getStandardDeviationX2();
    						}
    					}
    					else {
    						if ((tsRegressionDataTransformed.getMonthlyEquationRegressionData(iEquation).getN2() == 0)) {
    							statisticValueDouble[countStatistic] = null;
    						}
    						else {
    							statisticValueDouble[countStatistic] = 
    								tsRegressionDataTransformed.getMonthlyEquationRegressionData(iEquation).getStandardDeviationX2();
    						}
    					}
    				}
    				else if ( statisticName.equals("SY") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getStandardDeviationY();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getStandardDeviationY();
    					}
    				}
    				else if ( statisticName.equals("SY_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionDataTransformed.getSingleEquationRegressionData().getStandardDeviationY();
    					}
    					else {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getMonthlyEquationRegressionData(iEquation).getStandardDeviationY();
    					}
    				}
    				else if ( statisticName.equals("SY1") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getSingleEquationRegressionData().getStandardDeviationY1();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionData.getMonthlyEquationRegressionData(iEquation).getStandardDeviationY1();
    					}
    				}
    				else if ( statisticName.equals("SY1_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getSingleEquationRegressionData().getStandardDeviationY1();
    					}
    					else {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionDataTransformed.getMonthlyEquationRegressionData(iEquation).getStandardDeviationY1();
    					}
    				}
    				else if ( statisticName.equals("SY1est") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getStandardDeviationY1est();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getStandardDeviationY1est();
    					}
    				}
    				else if ( statisticName.equals("SY1est_trans") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] = 
    							tsRegressionEstimateErrorsTransformed.getSingleEquationRegressionErrors().getStandardDeviationY1est();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrorsTransformed.getMonthlyEquationRegressionErrors(iEquation).getStandardDeviationY1est();
    					}
    				}
    				else if ( statisticName.equals("SYfilled") ) {
    					// Actually filled values
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionFilledValues.getSingleEquationRegressionFilledValues().getStandardDeviationYFilled();
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionFilledValues.getMonthlyEquationRegressionFilledValues(iEquation).getStandardDeviationYFilled();
    					}
    				}
    				else if ( statisticName.equals("TestScore") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getTestScore(
    									tsRegressionResults.getSingleEquationRegressionResults().getB());
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getTestScore(
    									tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getB() );
    					}
    				}
    				else if ( statisticName.equals("TestQuantile") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					if ( numEquations == 1 ) {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getStudentTTestQuantile(
    									tsRegressionChecks.getSingleEquationRegressionChecks().getConfidenceIntervalPercent());
    					}
    					else {
    						statisticValueDouble[countStatistic] =
    							tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getStudentTTestQuantile(
    									tsRegressionChecks.getMonthlyEquationRegressionChecks(iEquation).getConfidenceIntervalPercent() );
    					}
    				}
    				else if ( statisticName.equals("TestOK") ) {
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_STRING;
    					// Only have a value if the confidence interval has been specified
    					if ( analysis.getConfidenceIntervalPercent() == null ) {
    						statisticValueString[countStatistic] = "";
    					}
    					else {
    						Boolean related = null;
    						if (numEquations == 1) {
    							related = tsRegressionChecks.getSingleEquationRegressionChecks().getIsTestOK();
    						}
    						else {
    							related = tsRegressionChecks.getMonthlyEquationRegressionChecks(iEquation).getIsTestOK();
    						}
    						if ( related == null ) {
    							statisticValueString[countStatistic] = "";
    						}
    						else if ( related ) {
    							statisticValueString[countStatistic] = "Yes";
    						}
    						else {
    							statisticValueString[countStatistic] = "No";
    						}
    					}
    				}
    				else {
    					// Fall through for unrecognized statistics
    					statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
    					statisticValueDouble[countStatistic] = null;
    					Message.printStatus ( 2, routine, "Don't know how to process statistic \"" + statisticName + "\"" );

    				}
    			}
    			catch ( Exception e ) {
    				// TODO SAM 2013-04-21 Need to figure out how to handle invalid sample size as null, NaN, etc.
    				// Could be zero sample size
    				// statisticFieldType[countStatistic] should have been set above so just set value
    				statisticValueDouble[countStatistic] = null;
    				Message.printWarning ( 3, routine, "Error computing \"" + statisticName + "\" (" + e + ")" );
    			}
    		}
    	}
    	// By here the statistics will have been computed and are matched with the column name array
    	// Now loop through again and process the row for the dependent and independent time series
    	// First format the dependent and independent time series identifiers for to match the table...
    	// Dependent time series identifier is configurable from parameter
    	String tableTSIDDependent = null;
    	if ( (tableTSIDFormat != null) && !tableTSIDFormat.equals("") ) {
    		// Format the TSID using the specified format
    		tableTSIDDependent = ts.formatLegend ( tableTSIDFormat );
    	}
    	else {
    		// Use the alias if available and then the TSID
    		tableTSIDDependent = ts.getAlias();
    		if ( (tableTSIDDependent == null) || tableTSIDDependent.equals("") ) {
    			tableTSIDDependent = ts.getIdentifierString();
    		}
    	}
    	// Get the independent time series identifier
    	String tableTSIDIndependent = null;
    	if ( (tableTSIDFormat != null) && !tableTSIDFormat.equals("") ) {
    		// Format the TSID using the specified format
    		tableTSIDIndependent = analysis.getIndependentTS().formatLegend ( tableTSIDFormat );
    	}
    	else {
    		// Use the alias if available and then the TSID
    		tableTSIDIndependent = analysis.getIndependentTS().getAlias();
    		if ( (tableTSIDIndependent == null) || tableTSIDIndependent.equals("") ) {
    			tableTSIDIndependent = analysis.getIndependentTS().getIdentifierString();
    		}
    	}
    	// Need to make sure that the table has the statistic columns of the correct type,
    	// and look up the column numbers from the names in order to do the insert...
    	int [] statisticColumnNumbers = new int[countStatisticTotal]; // columns in table
    	countStatistic = -1;
    	for ( int iEquation = 0; iEquation < numEquations; iEquation++ ) {
    		for ( int iStatistic = 0; iStatistic < statsToOutput.size(); iStatistic++ ) {
    			++countStatistic;
    			try {
    				statisticColumnNumbers[countStatistic] = table.getFieldIndex ( statisticColumnNames[countStatistic] );
    			}
    			catch ( Exception e ) {
    				statisticColumnNumbers[countStatistic] = -1; // Indicates no column name matched in table
    			}
    			if ( statisticColumnNumbers[countStatistic] < 0 ) {
    				// The statistic column does not exist, so add and initialize with null (not nonValue)
    				// The value will be set below.
    				if ( statisticFieldType[countStatistic] == TableField.DATA_TYPE_DOUBLE ) {
    					// Use precision of 8, which should cover most statistics without roundoff
    					// (although this may be too many significant digits for some input).
    					statisticColumnNumbers[countStatistic] =
    						table.addField(new TableField(
    								TableField.DATA_TYPE_DOUBLE,statisticColumnNames[countStatistic],-1,8), null );
    				}
    				else if ( statisticFieldType[countStatistic] == TableField.DATA_TYPE_INT ) {
    					statisticColumnNumbers[countStatistic] =
    						table.addField(new TableField(
    								TableField.DATA_TYPE_INT,statisticColumnNames[countStatistic],-1,-1), null );
    				}
    				else if ( statisticFieldType[countStatistic] == TableField.DATA_TYPE_STRING ) {
    					statisticColumnNumbers[countStatistic] =
    						table.addField(new TableField(
    								TableField.DATA_TYPE_STRING,statisticColumnNames[countStatistic],-1,-1), null );
    				}
    				Message.printStatus(2,routine,"Added column \"" + statisticColumnNames[countStatistic] +"\" at index ["
    						+ statisticColumnNumbers[countStatistic] + "]");
    				// Set the description for the column so that it can be displayed in table tooltips, etc.
    				if ( numEquations == 1 ) {
    					table.getTableField(statisticColumnNumbers[countStatistic]).setDescription(
    							statisticComments.get(statisticColumnNames[countStatistic]));
    				}
    				else {
    					table.getTableField(statisticColumnNumbers[countStatistic]).setDescription(
    							statisticComments.get(statisticColumnNames[countStatistic]) +
    							" (Month " + (iEquation + 1) + "=" + TimeUtil.monthAbbreviation(iEquation + 1)+")");
    				}
    			}
    		}
    	}
    	// Next, find the record that has the dependent and independent identifiers...
    	// Find the record that matches the dependent and independent identifiers (should only be one but
    	// handle multiple matches)
    	List<String> tableColumnNames = new Vector<String>(); // The dependent and independent TSID column names
    	tableColumnNames.add ( tableTSIDColumnName );
    	tableColumnNames.add ( tableTSIDColumnNameIndependent );
    	List<String> tableColumnValues = new Vector<String>(); // The dependent and independent TSID values
    	tableColumnValues.add ( tableTSIDDependent );
    	tableColumnValues.add ( tableTSIDIndependent );
    	List<TableRecord> recList = table.getRecords ( tableColumnNames, tableColumnValues );
    	Message.printStatus(2,routine,"Searched for records with columns matching \"" +
    			tableTSIDColumnName + "\"=\"" + tableTSIDDependent + "\" " +
    			tableTSIDColumnNameIndependent + "\"=\"" + tableTSIDIndependent + "\"... found " + recList.size() );
    	if ( recList.size() == 0 ) {
    		// No record in the table so add one with TSID column values and blank statistic values...
    		TableRecord rec = null;
    		table.addRecord(rec=table.emptyRecord());
    		rec.setFieldValue(tableTSIDColumnNumber, tableTSIDDependent);
    		rec.setFieldValue(tableTSIDColumnNumberIndependent, tableTSIDIndependent);
    		recList.add ( rec );
    	}
    	// Finally loop through the statistics and insert into the rows matched above.  Although multiple
    	// records may have been matched, the normal case will be that one record is matched.
    	for ( TableRecord rec : recList ) {
    		// Set the static column contents
    		rec.setFieldValue(table.getFieldIndex("AnalysisMethod"), getAnalysisMethod() );
    		rec.setFieldValue(table.getFieldIndex("DependentAnalysisStart"), getDependentAnalysisStart() );
    		rec.setFieldValue(table.getFieldIndex("DependentAnalysisEnd"), getDependentAnalysisEnd() );
    		rec.setFieldValue(table.getFieldIndex("IndependentAnalysisStart"), getIndependentAnalysisStart() );
    		rec.setFieldValue(table.getFieldIndex("IndependentAnalysisEnd"), getIndependentAnalysisEnd() );
    		rec.setFieldValue(table.getFieldIndex("FillStart"), getFillStart() );
    		rec.setFieldValue(table.getFieldIndex("FillEnd"), getFillEnd() );
    		rec.setFieldValue(table.getFieldIndex("MinimumSampleSize"), getMinimumSampleSize() );
    		rec.setFieldValue(table.getFieldIndex("MinimumR"), getMinimumR() );
    		rec.setFieldValue(table.getFieldIndex("ConfidenceInterval"), analysis.getConfidenceIntervalPercent() );
    		rec.setFieldValue(table.getFieldIndex("Transformation"), analysis.getTransformation() );
    		countStatistic = -1;
    		// Set the statistic columns for values that were actually used.
    		for ( int iEquation = 0; iEquation < numEquations; iEquation++ ) {
    			for ( int iStatistic = 0; iStatistic < statsToOutput.size(); iStatistic++ ) {
    				// Set the value based on the object type for the statistic.
    				// There can only be one non-null statistic value
    				++countStatistic;
    				if ( statisticValueDouble[countStatistic] != null ) {
    					rec.setFieldValue(statisticColumnNumbers[countStatistic],
    							statisticValueDouble[countStatistic]);
    				}
    				else if ( statisticValueInteger[countStatistic] != null ) {
    					rec.setFieldValue(statisticColumnNumbers[countStatistic],
    							statisticValueInteger[countStatistic]);
    				}
    				else if ( statisticValueString[countStatistic] != null ) {
    					rec.setFieldValue(statisticColumnNumbers[countStatistic],
    							statisticValueString[countStatistic]);
    				}
    			}
    		}
    	}
    }
}

/**
Set the TSRegressionFilledValues object.
*/
private void setTSRegressionFilledValues ( TSRegressionFilledValues fv )
{
    __tsRegressionFilledValues = fv;
}

}