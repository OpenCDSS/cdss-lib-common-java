// TSUtil_CheckTimeSeries - check time series values.

/* NoticeStart

CDSS Common Java Library
CDSS Common Java Library is a part of Colorado's Decision Support Systems (CDSS)
Copyright (C) 1994-2019 Colorado Department of Natural Resources

CDSS Common Java Library is free software:  you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CDSS Common Java Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CDSS Common Java Library.  If not, see <https://www.gnu.org/licenses/>.

NoticeEnd */

package RTi.TS;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.List;

import RTi.Util.Message.Message;
import RTi.Util.String.StringUtil;
import RTi.Util.Table.DataTable;
import RTi.Util.Table.TableField;
import RTi.Util.Table.TableRecord;
import RTi.Util.Time.DateTime;
import RTi.Util.Time.DateTimeWindow;

/**
Check time series values.
*/
public class TSUtil_CheckTimeSeries
{

/**
List of problems generated by this command, guaranteed to be non-null.
*/
private List<String> __problems = new ArrayList<>();

/**
Time series to process.
*/
private TS __ts = null;

/**
Type of check to perform.
*/
private CheckType __checkCriteria = null;

/**
Start of analysis (null to analyze all).
*/
private DateTime __analysisStart = null;

/**
End of analysis (null to analyze all).
*/
private DateTime __analysisEnd = null;

/**
Starting date/time for analysis window, within a year.
*/
private DateTime __analysisWindowStart = null;

/**
Ending date/time for analysis window, within a year.
*/
private DateTime __analysisWindowEnd = null;

/**
Value as input to analysis, depending on checkType.
*/
private Double __checkValue1 = null;

/**
Start of analysis (null to analyze all).
*/
private Double __checkValue2 = null;

/**
Problem type, flog problem logging (default is check type).
*/
private String __problemType = "";

/**
Number of checks that met the criteria.
*/
private int __checkCriteriaMetCount = 0;

/**
Flag string for detected values.
*/
private String __flag = null;

/**
Description for __flag.
*/
private String __flagDesc = null;

/**
Action to be performed on detection (either null/blank for no action, "Remove" to remove the data point,
or "SetMissing" to set the data point to missing.  For regular, Remove and SetMissing are equivalent.
*/
private String __action = null;

/**
Table to receive checks.
*/
private DataTable __table = null;

/**
Name of table column for TSID.
*/
private String __tableTSIDColumn = null;

/**
Column number for __tableTSIDColumn.
*/
private int __tableTSIDColumnNum = 4;

/**
Name of table column for date/time.
*/
private String __tableDateTimeColumn = null;

/**
Column number for __tableDateTimeColumn.
*/
private int __tableDateTimeColumnNum = -1;

/**
Name of table column for time series value.
*/
private String __tableValueColumn = null;

/**
Precision of value column output.
*/
private int __tableValuePrecision = -1;

/**
Column number for __tableValueColumn.
*/
private int __tableValueColumnNum = -1;

/**
Name of table column for time series flag.
*/
private String __tableFlagColumn = null;

/**
Column number for __tableFlagColumn.
*/
private int __tableFlagColumnNum = -1;

/**
Name of table check type column for time series flag.
*/
private String __tableCheckTypeColumn = null;

/**
Column number for __tableCheckTypeColumn.
*/
private int __tableCheckTypeColumnNum = -1;

/**
Name of table check message column for time series flag.
*/
private String __tableCheckMessageColumn = null;

/**
Column number for __tableCheckMessageColumn.
*/
private int __tableCheckMessageColumnNum = -1;

/**
Format of TSID for table TSID column.
*/
private String __tableTSIDFormat = null;

/**
Constructor.
@param ts time series to check
@param checkType the type of check to perform
@param analysisStart the start of the data period to check
@param analysisEnd the end of the data period to check
@param analysisWindowStart Starting date/time (year is ignored) for analysis within the year,
in precision of the original data.  If null, the entire year of data will be analyzed.
@param analysisWindowEnd Ending date (year is ignored) for analysis within the year,
in precision of the original data.  If null, the entire year of data will be analyzed.
@param checkValue1 the first value to check against (depends on check type)
@param checkValue2 the second value to check against (depends on check type)
@param problemType the string problem type to assign when data values match the check criteria (default is check criteria)
@param flag the data flag to assign to values that match the check criteria
@param flagDesc the description for the data flag (used in summary reports)
@param action the action to be taken for values that match the check criteria (in addition to flagging) - can
be "SetMissing" to set the data value to missing, or "Remove" to remove the point (for irregular time series,
equivalent to "SetMissing" for regular interval data)
@param table output DataTable - must have been created
@param tableTSIDColumn table column for TSID - will be added if not in the table
@param tableTSIDFormat format to format TSID for match in table, containing % specifiers and ${ts:property}
@param tableDateTimeColumn table column for date/time - will be added if not in the table
@param tableValueColumn table column for check values - will be added if not in the table
@param tableValuePrecision precision for tableValueColumn, or -1 to default
@param tableFlagColumn table column for time series flag corresponding to value - will be added if not in the table
@param tableCheckTypeColumn table column for check type - will be added if not in the table
@param tableCheckMessageColumn table column for check message - will be added if not in the table
*/
public TSUtil_CheckTimeSeries ( TS ts, CheckType checkType,
        DateTime analysisStart, DateTime analysisEnd, DateTime analysisWindowStart, DateTime analysisWindowEnd,
        Double checkValue1, Double checkValue2, String problemType,
        String flag, String flagDesc, String action, DataTable table, String tableTSIDColumn, String tableTSIDFormat,
        String tableDateTimeColumn, String tableValueColumn, int tableValuePrecision,
        String tableFlagColumn, String tableCheckTypeColumn, String tableCheckMessageColumn )
{   String message;
    String routine = getClass().getSimpleName();
	// Save data members.
    __ts = ts;
    __checkCriteria = checkType;
    __analysisStart = analysisStart;
    __analysisEnd = analysisEnd;
    __analysisWindowStart = analysisWindowStart;
    __analysisWindowEnd = analysisWindowEnd;
    __checkValue1 = checkValue1;
    __checkValue2 = checkValue2;
    if ( (problemType == null) || problemType.isEmpty() ) {
    	__problemType = "" + checkType;
    }
    __problemType = problemType;
    __flag = flag;
    __flagDesc = flagDesc;
    __action = action;
    __table = table;
    __tableTSIDColumn = tableTSIDColumn;
    __tableTSIDFormat = tableTSIDFormat;
    __tableDateTimeColumn = tableDateTimeColumn;
    __tableValueColumn = tableValueColumn;
    if ( tableValuePrecision < 0 ) {
    	__tableValuePrecision = 4; // Default.
    }
    else {
    	__tableValuePrecision = tableValuePrecision;
    }
    __tableFlagColumn = tableFlagColumn;
    __tableCheckTypeColumn = tableCheckTypeColumn;
    __tableCheckMessageColumn = tableCheckMessageColumn;
    if ( (__action != null) && __action.equals("") ) {
        // Set to null for internal handling.
        __action = null;
    }
    if ( (action != null) && !action.equalsIgnoreCase("Remove") && !action.equalsIgnoreCase("SetMissing")) {
        message = "Action (" + action + ") is invalid.  Must be Remove or SetMissing if specified";
        Message.printWarning(3, routine, message);
        throw new InvalidParameterException ( message );
    }
}

/**
Check that the output table is set up.  The following columns are included:
<ol>
<li>TSID</li>
<li>DateTime</li>
<li>Value</li>
<li>Flag</li>
<li>CheckType</li>
<li>CheckMessage</li>
</ol>
@param table table to set up
@param tableTSIDColumn name of column containing TSID
@param tableDateTimeColumn name of column containing date/time
@param tableValueColumn name of column containing value
@param tableValuePrecision precision of column containing value
@param tableFlagColumn name of column containing flag
@param tableCheckTypeColumn name of column containing check type
@param tableCheckMessageColumn name of column containing check message
@return true if table is being used, false if not.
*/
private boolean checkTableSetup ( DataTable table, String tableTSIDColumn, String tableDateTimeColumn,
	String tableValueColumn, int tableValuePrecision, String tableFlagColumn, String tableCheckTypeColumn,
	String tableCheckMessageColumn )
{	if ( table == null ) {
		return false;
	}
	try {
		if ( (tableTSIDColumn != null) && !tableTSIDColumn.isEmpty() ) {
			__tableTSIDColumnNum = table.getFieldIndex(tableTSIDColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it.
		__tableTSIDColumnNum = table.addField(0, new TableField(TableField.DATA_TYPE_STRING, tableTSIDColumn, -1, -1), "");
	}
	try {
		if ( (tableDateTimeColumn != null) && !tableDateTimeColumn.isEmpty() ) {
			__tableDateTimeColumnNum = table.getFieldIndex(tableDateTimeColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it.
		__tableDateTimeColumnNum = table.addField(1, new TableField(TableField.DATA_TYPE_DATETIME, tableDateTimeColumn, -1, -1), "");
	}
	try {
		if ( (tableValueColumn != null) && !tableValueColumn.isEmpty() ) {
			__tableValueColumnNum = table.getFieldIndex(tableValueColumn);
		}
	}
	catch ( Exception e ) {
		// The table column is not found so create it - use 4 digits of precision for the check output.
		__tableValueColumnNum = table.addField(2, new TableField(TableField.DATA_TYPE_DOUBLE, tableValueColumn, -1, tableValuePrecision), "");
	}
	try {
		if ( (tableFlagColumn != null) && !tableFlagColumn.isEmpty() ) {
			__tableFlagColumnNum = table.getFieldIndex(tableFlagColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it.
		__tableFlagColumnNum = table.addField(3,new TableField(TableField.DATA_TYPE_STRING, tableFlagColumn, -1, -1), "");
	}
	try {
		if ( (tableCheckTypeColumn != null) && !tableCheckTypeColumn.isEmpty() ) {
			__tableCheckTypeColumnNum = table.getFieldIndex(tableCheckTypeColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it.
		__tableCheckTypeColumnNum = table.addField(4,new TableField(TableField.DATA_TYPE_STRING, tableCheckTypeColumn, -1, -1), "");
	}
	try {
		if ( (tableCheckMessageColumn != null) && !tableCheckMessageColumn.isEmpty() ) {
			__tableCheckMessageColumnNum = table.getFieldIndex(tableCheckMessageColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it.
		__tableCheckMessageColumnNum = table.addField(5,new TableField(TableField.DATA_TYPE_STRING, tableCheckMessageColumn, -1, -1), "");
	}
	return true;
}

/**
Check the time series.
*/
public void checkTimeSeries ()
throws Exception
{	// Get class data for local processing.
	DataTable table = __table;
    // Create a new list of problems.
    __problems = new ArrayList<String>();
    int checkCriteriaMetCount = 0; // Number of values meeting the check criteria.
    TS ts = getTimeSeries();
    CheckType checkCriteria = getCheckCriteria();
    String tsid = ts.getIdentifier().toString();
    DateTime analysisWindowStart = getAnalysisWindowStart();
    DateTime analysisWindowEnd = getAnalysisWindowEnd();
    DateTimeWindow win = null;
    if ( (analysisWindowStart != null) && (analysisWindowEnd != null) ) {
    	win = new DateTimeWindow(analysisWindowStart,analysisWindowEnd);
    }
    
    // If time series has no data and check is for missing, add a message.
    // Otherwise skip.
    if ( !ts.hasData() ) {
        if ( checkCriteria == CheckType.MISSING ) {
            __problems.add ( "Time series " + tsid + " has no data." );
        }
        return;
    }
    
    double value1 = (getCheckValue1() == null) ? -999.0 : getCheckValue1().doubleValue();
    double value2 = (getCheckValue2() == null) ? -999.0 : getCheckValue2().doubleValue();
    if ( (ts.getAlias() != null) && !ts.getAlias().isEmpty() ) {
        tsid = ts.getAlias();
    }
    
    // If a table is being used for output, check that it has the required columns.
    boolean doTable = false;
    String tableTSID = ""; // Time series TSID formatted for table.
    if ( table != null ) {
    	doTable = checkTableSetup(table,__tableTSIDColumn,__tableDateTimeColumn,
    		__tableValueColumn,__tableValuePrecision,__tableFlagColumn,__tableCheckTypeColumn,
    		__tableCheckMessageColumn);
    	tableTSID = ts.formatLegend(__tableTSIDFormat);
    }
    
    // Some statistics require "look forward processing" beyond checking the previous value.
    // Detect those here and process in a separate method.
    
    if ( checkCriteria == CheckType.REPEAT ) {
        int value1Int = (int)(value1 + .01); // Ensure integer value given float parameter.
        if ( value1Int >= 2 ) {
            checkTimeSeriesLookForward ( value1Int );
        }
        else if ( value1Int < 2 ) {
            __problems.add ( "For check criteria " + CheckType.REPEAT + ", Value1 must be >= 2." );
        }
        return;
    } 
    
    // Iterate through the time series.

    TSIterator tsi = ts.iterator(getAnalysisStart(), getAnalysisEnd());
    TSData data = null;
    double tsvalue; // Time series data value.
    double tsvaluePrev = 0; // Time series data value (previous).
    String tsflag; // Time series data flag.
    int tsvalueCount = 0; // Number of values processed.
    String message = null;
    DateTime date; // Date corresponding to data value.
    boolean isMissing;
    boolean matchDetected; // Whether a data value matched the check criteria - used to trigger action.
    double diff;
    TSData dataPoint = new TSData(); // Used when setting the flag.
    // TODO SAM 2010 evaluate whether to check units for precision
    String tsValueFormat = "%.6f"; // Format for values for messages.
    while ( (data = tsi.next()) != null ) {
        // Analyze the value - do this brute force with string comparisons and improve performance once logic is in place.
        message = null; // A non-null message indicates that the check criteria was met for the value>
        date = tsi.getDate();
        // Check to see if the date is in the analysis window.
        if ( (win != null) && !win.isDateTimeInWindow(date) ) {
        	continue;
        }
        matchDetected = false;
        tsvalue = data.getDataValue();
        tsflag = data.getDataFlag();
        isMissing = ts.isDataMissing(tsvalue);
        if ( checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = tsvalue - tsvaluePrev;
                if ( Math.abs(diff) > value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat)
                        + " at " + date + " changed more than " +
                        value1 + " since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = ((tsvalue - tsvaluePrev)/tsvaluePrev)*100.0;
                if ( Math.abs(diff) > value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat) +
                        " at " + date + " changed more than " +
                        value1 + "% since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff %=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.CHANGE_GREATER_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = tsvalue - tsvaluePrev;
                if ( diff > value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat)
                        + " at " + date + " change is > " +
                        value1 + " since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.CHANGE_LESS_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = tsvalue - tsvaluePrev;
                if ( diff < value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat)
                        + " at " + date + " change is < " +
                        value1 + " since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.EQUAL_TO ) {
            if ( !isMissing && (tsvalue == value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is = test value " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.GREATER_THAN ) {
            if ( !isMissing && (tsvalue > value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is > limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO ) {
            if ( !isMissing && (tsvalue >= value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is >= limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.IN_RANGE ) {
            if ( !isMissing && (tsvalue >= value1) && (tsvalue <= value2) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is in range " + value1 + " to " + value2;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.LESS_THAN ) {
            if ( !isMissing && (tsvalue < value1) ) {
                message = "Time series " + tsid + " value " +
                    StringUtil.formatString(tsvalue,tsValueFormat) +
                    " at " + date + " is < limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO ) {
            if ( !isMissing && (tsvalue <= value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is <= limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.MISSING ) {
            if ( isMissing ) {
                message = "Time series " + tsid + " value " + 
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is missing";
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.OUT_OF_RANGE ) {
            if ( !isMissing && (tsvalue < value1) || (tsvalue > value2) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is out of range " + value1 + " to " + value2;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.REPEAT ) {
            if ( !isMissing && (tsvalueCount > 0) && !ts.isDataMissing(tsvalue) && !ts.isDataMissing(tsvalue) &&
                (tsvalue == tsvaluePrev) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " repeated previous value";
                matchDetected = true;
            }
        }
        if ( message != null ) {
            // Add to the problems list.
            __problems.add ( message );
            if ( __flag != null ) {
                // Update the flag value.
                dataPoint = ts.getDataPoint(date, dataPoint );
                dataPoint.setDataFlag ( __flag );
                ts.setDataValue(date, dataPoint.getDataValue(), dataPoint.getDataFlag(), dataPoint.getDuration() );
                // Set the flag for use by the table.
                tsflag = __flag;
            }
        }
        if ( matchDetected && doTable ) {
        	// Save the results to the table.
    		// Add a record to the table.
    		TableRecord rec = table.emptyRecord();
    		if ( __tableTSIDColumnNum >= 0 ) {
    			rec.setFieldValue(__tableTSIDColumnNum, tableTSID);
    		}
    		if ( __tableDateTimeColumnNum >= 0 ) {
    			// Make a copy since iterating.
    			rec.setFieldValue(__tableDateTimeColumnNum, new DateTime(date));
    		}
    		if ( __tableValueColumnNum >= 0 ) {
    			rec.setFieldValue(__tableValueColumnNum, tsvalue);
    		}
    		if ( __tableFlagColumnNum >= 0 ) {
    			rec.setFieldValue(__tableFlagColumnNum, tsflag);
    		}
    		if ( __tableCheckTypeColumnNum >= 0 ) {
    			rec.setFieldValue(__tableCheckTypeColumnNum, __problemType);
    		}
    		if ( __tableCheckMessageColumnNum >= 0 ) {
    			rec.setFieldValue(__tableCheckMessageColumnNum, message);
    		}
    		table.addRecord(rec);
        }
        // If an action is required, do it.
        if ( matchDetected ) {
        	++checkCriteriaMetCount;
        	if ( __action != null )  {
	            if ( __action.equalsIgnoreCase("Remove") ) {
	                if ( ts instanceof IrregularTS ) {
	                    // Remove the data point from memory.
	                    ((IrregularTS)ts).removeDataPoint(date);
	                }
	                else {
	                    // Set to missing.
	                    ts.setDataValue(date, ts.getMissing() );
	                }
	            }
	            else if ( __action.equalsIgnoreCase("SetMissing") ) {
	                ts.setDataValue(date, ts.getMissing() );
	            }
        	}
        }
        // Increment the count and save the previous value.
        ++tsvalueCount;
        tsvaluePrev = tsvalue;
    }
    if ( checkCriteriaMetCount > 0 ) {
    	this.__checkCriteriaMetCount = checkCriteriaMetCount;
	    if ( (__flag != null) && !__flag.isEmpty() ) {
	        // Remove leading + on flag, used to indicate concatenation.
	        String flag = StringUtil.remove(__flag,"+");
	        if ( (__flagDesc == null) || __flagDesc.equals("") ) {
	            // Default description.
	            message = "Detected " + checkCriteriaMetCount + " values where " + formatCriteriaForFlagDesc() + ".";
	            ts.addDataFlagMetadata(new TSDataFlagMetadata( flag, message));
	        }
	        else {
	            // Use supplied description.
	            message = "Detected " + checkCriteriaMetCount + " values where " + __flagDesc + ".";
	            ts.addDataFlagMetadata(new TSDataFlagMetadata( flag, message));
	        }
	        // Add a message to the genesis since flags have been set.
	        ts.addToGenesis ( message + "  Set flag to " + __flag + "." );
	    }
    }
}

/**
Check the time series for checks that need to look forward, including:
<ol>
<li>Repeat</li>
</ol>
It is expected that primary checks are done in the checkTimeSeries() method.
*/
private void checkTimeSeriesLookForward ( int value1 )
throws Exception
{
    TS ts = getTimeSeries();
    CheckType checkCriteria = getCheckCriteria();
    String tsid = ts.getIdentifier().toString();
    
    if ( (ts.getAlias() != null) && !ts.getAlias().isEmpty() ) {
        tsid = ts.getAlias();
    }
    
    if ( checkCriteria != CheckType.REPEAT ) {
        __problems.add ( "CheckTimeSeriesForward is only implemented for " + CheckType.REPEAT + ", logic problem." );
        return;
    }
    
    // Iterate through the time series.

    TSIterator tsi = ts.iterator(getAnalysisStart(), getAnalysisEnd()); // Overall period.
    TSIterator tsi2 = ts.iterator(getAnalysisStart(), getAnalysisEnd()); // Search forward window.
    //TSIterator tsi3 = ts.iterator(getAnalysisStart(), getAnalysisEnd()); // Action window.
    TSData data = null; // Initial data point.
    TSData data2 = null; // Data point looking forward.
    double tsvalue; // Time series data value.
    double tsvalue2; // Time series data value looking forward.
    String message = null;
    DateTime date2; // Date corresponding to search forward.
    DateTime startToAdjust; // Date corresponding to first offending value requiring adjustment.
    DateTime endToAdjust; // Date corresponding to last offending value requiring adjustment.
    TSData dataPoint = new TSData();
    // TODO SAM 2010 evaluate whether to check units for precision.
    String tsValueFormat = "%.6f"; // Format for values for messages.
    int countConditionMet = 0; // Number of times that forward values match condition.
    int value1m1 = value1 - 1; // To simplify code.
    while ( (data = tsi.next()) != null ) {
        // Time series value at the current interval.
        tsvalue = data.getDataValue();
        //Message.printStatus(2, "", "Checking value " + tsvalue + " at " + data.getDate() + " for repeat." );
        // Skip over missing.
        if ( ts.isDataMissing(tsvalue) ) {
            continue;
        }
        // Look forward while values are the same.  Afterwards, deal with the sequence.
        date2 = data.getDate();
        tsi2.setBeginTime( date2 );
        // Advance one so as to start comparison with value after.
        tsi2.next();
        countConditionMet = 0;
        startToAdjust = null;
        endToAdjust = null;
        while ( (data2 = tsi2.next()) != null ) {
            tsvalue2 = data2.getDataValue();
            if ( tsvalue == tsvalue2 ) {
                ++countConditionMet;
                if ( countConditionMet >= value1m1 ) {
                    // Save the first "offending" date/time that will need adjusting.
                    if ( startToAdjust == null ) {
                        startToAdjust = new DateTime(data2.getDate());
                    }
                    // Also save the last "offending" date/time that will need adjusting.
                    endToAdjust = new DateTime(data2.getDate());
                }
            }
            else {
                // No more matching values - break and take necessary action below.
                break;
            }
        }
        // Now evaluate the number of matching values.
        // A parameter of Value1=2 means that 2 repeating values triggers the response to the check,
        // for the 2nd+ values.
        if ( countConditionMet >= value1m1 ) {
            // Take action on the offending values and reset the main iterator to start after the adjusted sequence.
            // If an action is required, do it.
            //tsi3.setBeginTime(startToAdjust);
            //tsi3.setEndTime(endToAdjust);
        	TSIterator tsi3 = ts.iterator(startToAdjust, endToAdjust);
            int count = value1m1;
            while ( (data2 = tsi3.next()) != null ) {
                date2 = data2.getDate();
                tsvalue2 = data2.getDataValue();
                ++count;
                message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue2,tsValueFormat)
                + " at " + date2 + " repeated (occurrence: " + count + ").";
                // Add to the problems list.
                __problems.add ( message );
                if ( __flag != null ) {
                    // Update the flag value.
                    dataPoint = ts.getDataPoint(date2, dataPoint );
                    dataPoint.setDataFlag ( __flag );
                    ts.setDataValue(date2, dataPoint.getDataValue(), dataPoint.getDataFlag(), dataPoint.getDuration() );
                }
                if ( __action != null )  {
                    if ( __action.equalsIgnoreCase("Remove") ) {
                        if ( ts instanceof IrregularTS ) {
                            // Remove the data point from memory.
                            ((IrregularTS)ts).removeDataPoint(date2);
                        }
                        else {
                            // Set to missing
                            ts.setDataValue(date2, ts.getMissing() );
                        }
                    }
                    else if ( __action.equalsIgnoreCase("SetMissing") ) {
                        ts.setDataValue(date2, ts.getMissing() );
                    }
                }
            }
            // Advance the main iterator to start checking the next value after the sequence.
            tsi.setBeginTime(endToAdjust);
            tsi.next(); // Will return the new begin time.
        }
        else {
            // No conditions met.  No action taken.
            // Just advance the iterator and check the next sequence.
        }
    }
    // Final data annotations based on full count of matches.
    if ( (__flag != null) && !__flag.equals("") && (__problems.size() > 0) ) {
        // Remove leading + on flag, used to indicate concatenation.
        String flag = StringUtil.remove(__flag,"+");
        if ( (__flagDesc == null) || __flagDesc.equals("") ) {
            // Default description.
            message = "Detected " + __problems.size() + " values where " + formatCriteriaForFlagDesc() + ".";
            ts.addDataFlagMetadata(new TSDataFlagMetadata( flag, message));
        }
        else {
            // Use supplied description.
            message = "Detected " + __problems.size() + " values where " + __flagDesc + ".";
            ts.addDataFlagMetadata(new TSDataFlagMetadata( flag, message));
        }
        // Add a message to the genesis since flags have been set.
        ts.addToGenesis ( message + "  Set flag to " + __flag + "." );
    }
}

/**
Format the criteria for use in output.
@return a string that describes the criteria, suitable for the flag description.
*/
private String formatCriteriaForFlagDesc ()
{
    if ( __checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN ) {
        return "abs(change(value)) > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN ) {
        return "percent(abs(change(value))) > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.CHANGE_GREATER_THAN ) {
        return "change(value) > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.CHANGE_LESS_THAN ) {
        return "change(value) < " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.IN_RANGE ) {
        return StringUtil.formatString(__checkValue1,"%.6f") + " <= value <= " +
            StringUtil.formatString(__checkValue2,"%.6f");
    }
    else if ( __checkCriteria == CheckType.OUT_OF_RANGE ) {
        return "value < " + StringUtil.formatString(__checkValue1,"%.6f") + " OR value > " +
        StringUtil.formatString(__checkValue2,"%.6f");
    }
    else if ( __checkCriteria == CheckType.MISSING ) {
        return "value is missing";
    }
    else if ( __checkCriteria == CheckType.REPEAT ) {
        return "value repeats previous value";
    }
    else if ( __checkCriteria == CheckType.LESS_THAN ) {
        return "value < " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO ) {
        return "value <= " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.GREATER_THAN ) {
        return "value > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO ) {
        return "value >= " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.EQUAL_TO ) {
        return "value = " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else {
        throw new InvalidParameterException ( "Unrecognized check criteria \"" + __checkCriteria + "\"" );
    }
}

/**
Return the analysis end date/time.
@return the analysis end date/time.
*/
public DateTime getAnalysisEnd ()
{
    return __analysisEnd;
}

/**
Return the analysis start date/time.
@return the analysis start date/time.
*/
public DateTime getAnalysisStart ()
{
    return __analysisStart;
}

/**
Return the analysis window end date/time.
@return the analysis window end date/time.
*/
public DateTime getAnalysisWindowEnd ()
{
    return __analysisWindowEnd;
}

/**
Return the analysis window start date/time.
@return the analysis window start date/time.
*/
public DateTime getAnalysisWindowStart ()
{
    return __analysisWindowStart;
}

/**
Return the check type.
@return the check type.
*/
public CheckType getCheckCriteria ()
{
    return __checkCriteria;
}

/**
Get the list of check types that can be performed.
*/
public static List<CheckType> getCheckCriteriaChoices()
{
    List<CheckType> choices = new ArrayList<CheckType>();
    choices.add ( CheckType.ABS_CHANGE_GREATER_THAN );
    choices.add ( CheckType.ABS_CHANGE_PERCENT_GREATER_THAN );
    choices.add ( CheckType.CHANGE_GREATER_THAN );
    choices.add ( CheckType.CHANGE_LESS_THAN );
    choices.add ( CheckType.IN_RANGE );
    choices.add ( CheckType.OUT_OF_RANGE );
    choices.add ( CheckType.MISSING );
    choices.add ( CheckType.REPEAT );
    choices.add ( CheckType.LESS_THAN );
    choices.add ( CheckType.LESS_THAN_OR_EQUAL_TO );
    choices.add ( CheckType.GREATER_THAN );
    choices.add ( CheckType.GREATER_THAN_OR_EQUAL_TO );
    choices.add ( CheckType.EQUAL_TO );
    return choices;
}

/**
Get the list of statistics that can be performed.
@return the statistic display names as strings.
*/
public static List<String> getCheckCriteriaChoicesAsStrings()
{
    List<CheckType> choices = getCheckCriteriaChoices();
    List<String> stringChoices = new ArrayList<String>();
    for ( int i = 0; i < choices.size(); i++ ) {
        stringChoices.add ( "" + choices.get(i) );
    }
    return stringChoices;
}

/**
Return the number of values where the check criteria was met.
*/
public int getCheckCriteriaMetCount()
{
	return __checkCriteriaMetCount;
}

/**
Return the number of values that are required to evaluate a criteria.
@return the number of values that are required to evaluate a criteria.
@param checkCriteria the check criteria that is being evaluated.
*/
public static int getRequiredNumberOfValuesForCheckCriteria ( CheckType checkCriteria )
{
    // TODO SAM 2009-04-23 Need to convert to enumeration or something other than simple strings
    if ( checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.CHANGE_GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.CHANGE_LESS_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.EQUAL_TO ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.NOT_EQUAL_TO ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.IN_RANGE ) {
        return 2;
    }
    else if ( checkCriteria == CheckType.LESS_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.MISSING ) {
        return 0;
    }
    else if ( checkCriteria == CheckType.OUT_OF_RANGE ) {
        return 2;
    }
    else if ( checkCriteria == CheckType.REPEAT ) {
        return 1;
    }
    else {
        String message = "Requested criteria is not recognized: " + checkCriteria;
        String routine = "TSUtil_CheckTimeSeries.getRequiredNumberOfValuesForCheckCriteria";
        Message.printWarning(3, routine, message);
        throw new InvalidParameterException ( message );
    }
}

/**
Return a list of problems for the time series.
*/
public List<String> getProblems ()
{
    return __problems;
}

/**
Return the time series being analyzed.
@return the time series being analyzed.
*/
public TS getTimeSeries ()
{
    return __ts;
}

/**
Return the first check constraint value.
@return the first check constraint value
*/
public Double getCheckValue1 ()
{
    return __checkValue1;
}

/**
Return the second check constraint value
@return the second check constraint value
*/
public Double getCheckValue2 ()
{
    return __checkValue2;
}

}