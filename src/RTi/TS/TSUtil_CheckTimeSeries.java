package RTi.TS;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;

import RTi.Util.Message.Message;
import RTi.Util.String.StringUtil;
import RTi.Util.Table.DataTable;
import RTi.Util.Table.TableField;
import RTi.Util.Table.TableRecord;
import RTi.Util.Time.DateTime;

/**
Check time series values.
*/
public class TSUtil_CheckTimeSeries
{

/**
List of problems generated by this command, guaranteed to be non-null.
*/
private List<String> __problems = new ArrayList<String>();

/**
Time series to process.
*/
private TS __ts = null;

/**
Type of check to perform.
*/
private CheckType __checkCriteria = null;

/**
Start of analysis (null to analyze all).
*/
private DateTime __analysisStart = null;

/**
End of analysis (null to analyze all).
*/
private DateTime __analysisEnd = null;

/**
Value as input to analysis, depending on checkType.
*/
private Double __checkValue1 = null;

/**
Start of analysis (null to analyze all).
*/
private Double __checkValue2 = null;

/**
Problem type, flog problem logging (default is check type).
*/
private String __problemType = "";

/**
Number of checks that met the criteria.
*/
private int __checkCriteriaMetCount = 0;

/**
Flag string for detected values.
*/
private String __flag = null;

/**
Description for __flag.
*/
private String __flagDesc = null;

/**
Action to be performed on detection (either null/blank for no action, "Remove" to remove the data point,
or "SetMissing" to set the data point to missing.  For regular, Remove and SetMissing are equivalent.
*/
private String __action = null;

/**
Table to receive checks.
*/
private DataTable __table = null;

/**
Name of table column for TSID.
*/
private String __tableTSIDColumn = null;

/**
Column number for __tableTSIDColumn.
*/
private int __tableTSIDColumnNum = -1;

/**
Name of table column for date/time.
*/
private String __tableDateTimeColumn = null;

/**
Column number for __tableDateTimeColumn.
*/
private int __tableDateTimeColumnNum = -1;

/**
Name of table column for time series value.
*/
private String __tableValueColumn = null;

/**
Column number for __tableValueColumn.
*/
private int __tableValueColumnNum = -1;

/**
Name of table column for time series flag.
*/
private String __tableFlagColumn = null;

/**
Column number for __tableFlagColumn.
*/
private int __tableFlagColumnNum = -1;

/**
Name of table check type column for time series flag.
*/
private String __tableCheckTypeColumn = null;

/**
Column number for __tableCheckTypeColumn.
*/
private int __tableCheckTypeColumnNum = -1;

/**
Name of table check message column for time series flag.
*/
private String __tableCheckMessageColumn = null;

/**
Column number for __tableCheckMessageColumn.
*/
private int __tableCheckMessageColumnNum = -1;

/**
Format of TSID for table TSID column.
*/
private String __tableTSIDFormat = null;

/**
Constructor.
@param ts time series to check
@param checkType the type of check to perform
@param analysisStart the start of the data period to check
@param analysisEnd the end of the data period to check
@param checkValue1 the first value to check against (depends on check type)
@param checkValue2 the second value to check against (depends on check type)
@param problemType the string problem type to assign when data values match the check criteria (default is check criteria)
@param flag the data flag to assign to values that match the check criteria
@param flagDesc the description for the data flag (used in summary reports)
@param action the action to be taken for values that match the check criteria (in addition to flagging) - can
be "SetMissing" to set the data value to missing, or "Remove" to remove the point (for irregular time series,
equivalent to "SetMissing" for regular interval data)
@param table output DataTable - must have been created
@param tsidColumn table column for TSID - will be added if not in the table
@param tsidFormat format to format TSID for match in table, containing % specifiers and ${ts:property}
*/
public TSUtil_CheckTimeSeries ( TS ts, CheckType checkType,
        DateTime analysisStart, DateTime analysisEnd, Double checkValue1, Double checkValue2, String problemType,
        String flag, String flagDesc, String action, DataTable table, String tableTSIDColumn, String tableTSIDFormat,
        String tableDateTimeColumn, String tableValueColumn, String tableFlagColumn, String tableCheckTypeColumn,
        String tableCheckMessageColumn )
{   String message;
    String routine = getClass().getSimpleName() + ".constructor";
	// Save data members.
    __ts = ts;
    __checkCriteria = checkType;
    __analysisStart = analysisStart;
    __analysisEnd = analysisEnd;
    __checkValue1 = checkValue1;
    __checkValue2 = checkValue2;
    if ( (problemType == null) || problemType.isEmpty() ) {
    	__problemType = "" + checkType;
    }
    __problemType = problemType;
    __flag = flag;
    __flagDesc = flagDesc;
    __action = action;
    __table = table;
    __tableTSIDColumn = tableTSIDColumn;
    __tableTSIDFormat = tableTSIDFormat;
    __tableDateTimeColumn = tableDateTimeColumn;
    __tableValueColumn = tableValueColumn;
    __tableFlagColumn = tableFlagColumn;
    __tableCheckTypeColumn = tableCheckTypeColumn;
    __tableCheckMessageColumn = tableCheckMessageColumn;
    if ( (__action != null) && __action.equals("") ) {
        // Set to null for internal handling
        __action = null;
    }
    if ( (action != null) && !action.equalsIgnoreCase("Remove") && !action.equalsIgnoreCase("SetMissing")) {
        message = "Action (" + action + ") is invalid.  Must be Remove or SetMissing if specified";
        Message.printWarning(3, routine, message);
        throw new InvalidParameterException ( message );
    }
}

/**
Check that the output table is set up.  The following columns are included:
<ol>
<li>TSID</li>
<li>DateTime</li>
<li>Value</li>
<li>Flag</li>
<li>CheckType</li>
<li>CheckMessage</li>
</ol>
@param table table to set up
@param tableTSIDColumn name of column containing TSID
@param tableDateTimeColumn name of column containing date/time
@param tableValueColumn name of column containing value
@param tableFlagColumn name of column containing flag
@param tableCheckTypeColumn name of column containing check type
@param tableCheckMessageColumn name of column containing check message
@return true if table is being used, false if not.
*/
private boolean checkTableSetup ( DataTable table, String tableTSIDColumn, String tableDateTimeColumn,
	String tableValueColumn, String tableFlagColumn, String tableCheckTypeColumn,
	String tableCheckMessageColumn )
{	if ( table == null ) {
		return false;
	}
	try {
		if ( (tableTSIDColumn != null) && !tableTSIDColumn.isEmpty() ) {
			__tableTSIDColumnNum = table.getFieldIndex(tableTSIDColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it
		__tableTSIDColumnNum = table.addField(0, new TableField(TableField.DATA_TYPE_STRING, tableTSIDColumn, -1, -1), "");
	}
	try {
		if ( (tableDateTimeColumn != null) && !tableDateTimeColumn.isEmpty() ) {
			__tableDateTimeColumnNum = table.getFieldIndex(tableDateTimeColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it
		__tableDateTimeColumnNum = table.addField(1, new TableField(TableField.DATA_TYPE_DATETIME, tableDateTimeColumn, -1, -1), "");
	}
	try {
		if ( (tableValueColumn != null) && !tableValueColumn.isEmpty() ) {
			__tableValueColumnNum = table.getFieldIndex(tableValueColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it
		__tableValueColumnNum = table.addField(2, new TableField(TableField.DATA_TYPE_DOUBLE, tableValueColumn, -1, -1), "");
	}
	try {
		if ( (tableFlagColumn != null) && !tableFlagColumn.isEmpty() ) {
			__tableFlagColumnNum = table.getFieldIndex(tableFlagColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it
		__tableFlagColumnNum = table.addField(3,new TableField(TableField.DATA_TYPE_STRING, tableFlagColumn, -1, -1), "");
	}
	try {
		if ( (tableCheckTypeColumn != null) && !tableCheckTypeColumn.isEmpty() ) {
			__tableCheckTypeColumnNum = table.getFieldIndex(tableCheckTypeColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it
		__tableCheckTypeColumnNum = table.addField(4,new TableField(TableField.DATA_TYPE_STRING, tableCheckTypeColumn, -1, -1), "");
	}
	try {
		if ( (tableCheckMessageColumn != null) && !tableCheckMessageColumn.isEmpty() ) {
			__tableCheckMessageColumnNum = table.getFieldIndex(tableCheckMessageColumn);
		}
	}
	catch ( Exception e ) {
		// Not found so create it
		__tableCheckMessageColumnNum = table.addField(5,new TableField(TableField.DATA_TYPE_STRING, tableCheckMessageColumn, -1, -1), "");
	}
	return true;
}

/**
Check the time series.
*/
public void checkTimeSeries ()
throws Exception
{	// Get class data for local processing
	DataTable table = __table;
    // Create a new list of problems
    __problems = new ArrayList<String>();
    int checkCriteriaMetCount = 0; // Number of values meeting the check criteria
    TS ts = getTimeSeries();
    CheckType checkCriteria = getCheckCriteria();
    String tsid = ts.getIdentifier().toString();
    
    // If time series has no data and check is for missing, add a message.
    // Otherwise skip
    if ( !ts.hasData() ) {
        if ( checkCriteria == CheckType.MISSING ) {
            __problems.add ( "Time series " + tsid + " has no data." );
        }
        return;
    }
    
    double value1 = (getCheckValue1() == null) ? -999.0 : getCheckValue1().doubleValue();
    double value2 = (getCheckValue2() == null) ? -999.0 : getCheckValue2().doubleValue();
    if ( (ts.getAlias() != null) && !ts.getAlias().isEmpty() ) {
        tsid = ts.getAlias();
    }
    
    // If a table is being used for output, check that it has the required columns
    boolean doTable = false;
    String tableTSID = ""; // Time series TSID formatted for table
    if ( table != null ) {
    	doTable = checkTableSetup(table,__tableTSIDColumn,__tableDateTimeColumn,
    		__tableValueColumn,__tableFlagColumn,__tableCheckTypeColumn,
    		__tableCheckMessageColumn);
    	tableTSID = ts.formatLegend(__tableTSIDFormat);
    }
    
    // Some statistics require "look forward processing" beyond checking the previous value.
    // Detect those here and process in a separate method
    
    if ( checkCriteria == CheckType.REPEAT ) {
        int value1Int = (int)(value1 + .01); // Ensure integer value given float parameter
        if ( value1Int >= 2 ) {
            checkTimeSeriesLookForward ( value1Int );
        }
        else if ( value1Int < 2 ) {
            __problems.add ( "For check criteria " + CheckType.REPEAT + ", Value1 must be >= 2." );
        }
        return;
    } 
    
    // Iterate through the time series

    TSIterator tsi = ts.iterator(getAnalysisStart(), getAnalysisEnd());
    TSData data = null;
    double tsvalue; // time series data value
    double tsvaluePrev = 0; // time series data value (previous)
    String tsflag; // time series data flag
    int tsvalueCount = 0; // Number of values processed
    String message = null;
    DateTime date; // Date corresponding to data value
    boolean isMissing;
    boolean matchDetected; // whether a data value matched the check criteria - used to trigger action
    double diff;
    TSData dataPoint = new TSData(); // Used when setting the flag
    // TODO SAM 2010 evaluate whether to check units for precision
    String tsValueFormat = "%.6f"; // Format for values for messages
    while ( (data = tsi.next()) != null ) {
        // Analyze the value - do this brute force with string comparisons and improve performance once logic is in place
        message = null; // A non-null message indicates that the check criteria was met for the value
        date = tsi.getDate();
        matchDetected = false;
        tsvalue = data.getDataValue();
        tsflag = data.getDataFlag();
        isMissing = ts.isDataMissing(tsvalue);
        if ( checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = tsvalue - tsvaluePrev;
                if ( Math.abs(diff) > value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat)
                        + " at " + date + " changed more than " +
                        value1 + " since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = ((tsvalue - tsvaluePrev)/tsvaluePrev)*100.0;
                if ( Math.abs(diff) > value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat) +
                        " at " + date + " changed more than " +
                        value1 + "% since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff %=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.CHANGE_GREATER_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = tsvalue - tsvaluePrev;
                if ( diff > value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat)
                        + " at " + date + " change is > " +
                        value1 + " since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.CHANGE_LESS_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = tsvalue - tsvaluePrev;
                if ( diff < value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat)
                        + " at " + date + " change is < " +
                        value1 + " since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.EQUAL_TO ) {
            if ( !isMissing && (tsvalue == value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is = test value " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.GREATER_THAN ) {
            if ( !isMissing && (tsvalue > value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is > limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO ) {
            if ( !isMissing && (tsvalue >= value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is >= limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.IN_RANGE ) {
            if ( !isMissing && (tsvalue >= value1) && (tsvalue <= value2) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is in range " + value1 + " to " + value2;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.LESS_THAN ) {
            if ( !isMissing && (tsvalue < value1) ) {
                message = "Time series " + tsid + " value " +
                    StringUtil.formatString(tsvalue,tsValueFormat) +
                    " at " + date + " is < limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO ) {
            if ( !isMissing && (tsvalue <= value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is <= limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.MISSING ) {
            if ( isMissing ) {
                message = "Time series " + tsid + " value " + 
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is missing";
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.OUT_OF_RANGE ) {
            if ( !isMissing && (tsvalue < value1) || (tsvalue > value2) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is out of range " + value1 + " to " + value2;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.REPEAT ) {
            if ( !isMissing && (tsvalueCount > 0) && !ts.isDataMissing(tsvalue) && !ts.isDataMissing(tsvalue) &&
                (tsvalue == tsvaluePrev) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " repeated previous value";
                matchDetected = true;
            }
        }
        if ( message != null ) {
            // Add to the problems list
            __problems.add ( message );
            if ( __flag != null ) {
                // Update the flag value
                dataPoint = ts.getDataPoint(date, dataPoint );
                dataPoint.setDataFlag ( __flag );
                ts.setDataValue(date, dataPoint.getDataValue(), dataPoint.getDataFlag(), dataPoint.getDuration() );
                // Set the flag for use by the table
                tsflag = __flag;
            }
        }
        if ( matchDetected && doTable ) {
        	// Save the results to the table
    		// Add a record to the table
    		TableRecord rec = table.emptyRecord();
    		if ( __tableTSIDColumnNum >= 0 ) {
    			rec.setFieldValue(__tableTSIDColumnNum, tableTSID);
    		}
    		if ( __tableDateTimeColumnNum >= 0 ) {
    			// Make a copy since iterating
    			rec.setFieldValue(__tableDateTimeColumnNum, new DateTime(date));
    		}
    		if ( __tableValueColumnNum >= 0 ) {
    			rec.setFieldValue(__tableValueColumnNum, tsvalue);
    		}
    		if ( __tableFlagColumnNum >= 0 ) {
    			rec.setFieldValue(__tableFlagColumnNum, tsflag);
    		}
    		if ( __tableCheckTypeColumnNum >= 0 ) {
    			rec.setFieldValue(__tableCheckTypeColumnNum, __problemType);
    		}
    		if ( __tableCheckMessageColumnNum >= 0 ) {
    			rec.setFieldValue(__tableCheckMessageColumnNum, message);
    		}
    		table.addRecord(rec);
        }
        // If an action is required, do it.
        if ( matchDetected ) {
        	++checkCriteriaMetCount;
        	if ( __action != null )  {
	            if ( __action.equalsIgnoreCase("Remove") ) {
	                if ( ts instanceof IrregularTS ) {
	                    // Remove the data point from memory
	                    ((IrregularTS)ts).removeDataPoint(date);
	                }
	                else {
	                    // Set to missing
	                    ts.setDataValue(date, ts.getMissing() );
	                }
	            }
	            else if ( __action.equalsIgnoreCase("SetMissing") ) {
	                ts.setDataValue(date, ts.getMissing() );
	            }
        	}
        }
        // Increment the count and save the previous value
        ++tsvalueCount;
        tsvaluePrev = tsvalue;
    }
    if ( checkCriteriaMetCount > 0 ) {
    	this.__checkCriteriaMetCount = checkCriteriaMetCount;
	    if ( (__flag != null) && !__flag.isEmpty() ) {
	        // Remove leading + on flag, used to indicate concatenation
	        String flag = StringUtil.remove(__flag,"+");
	        if ( (__flagDesc == null) || __flagDesc.equals("") ) {
	            // Default description...
	            message = "Detected " + checkCriteriaMetCount + " values where " + formatCriteriaForFlagDesc() + ".";
	            ts.addDataFlagMetadata(new TSDataFlagMetadata( flag, message));
	        }
	        else {
	            // Use supplied description...
	            message = "Detected " + checkCriteriaMetCount + " values where " + __flagDesc + ".";
	            ts.addDataFlagMetadata(new TSDataFlagMetadata( flag, message));
	        }
	        // Add a message to the genesis since flags have been set...
	        ts.addToGenesis ( message + "  Set flag to " + __flag + "." );
	    }
    }
}

/**
Check the time series for checks that need to look forward, including:
<ol>
<li>Repeat</li>
</ol>
It is expected that primary checks are done in the checkTimeSeries() method.
*/
private void checkTimeSeriesLookForward ( int value1 )
throws Exception
{
    TS ts = getTimeSeries();
    CheckType checkCriteria = getCheckCriteria();
    String tsid = ts.getIdentifier().toString();
    
    if ( (ts.getAlias() != null) && !ts.getAlias().isEmpty() ) {
        tsid = ts.getAlias();
    }
    
    if ( checkCriteria != CheckType.REPEAT ) {
        __problems.add ( "CheckTimeSeriesForward is only implemented for " + CheckType.REPEAT + ", logic problem." );
        return;
    }
    
    // Iterate through the time series

    TSIterator tsi = ts.iterator(getAnalysisStart(), getAnalysisEnd()); // Overall period
    TSIterator tsi2 = ts.iterator(getAnalysisStart(), getAnalysisEnd()); // Search forward window
    TSIterator tsi3 = ts.iterator(getAnalysisStart(), getAnalysisEnd()); // Action window
    TSData data = null; // Initial data point
    TSData data2 = null; // Data point looking forward
    double tsvalue; // time series data value
    double tsvalue2; // time series data value looking forward
    String message = null;
    DateTime date2; // Date corresponding to search forward
    DateTime startToAdjust; // Date corresponding to first offending value requiring adjustment
    DateTime endToAdjust; // Date corresponding to last offending value requiring adjustment
    TSData dataPoint = new TSData();
    // TODO SAM 2010 evaluate whether to check units for precision
    String tsValueFormat = "%.6f"; // Format for values for messages
    int countConditionMet = 0; // Number of times that forward values match condition
    int value1m1 = value1 - 1; // To simplify code
    while ( (data = tsi.next()) != null ) {
        // Time series value at the current interval
        tsvalue = data.getDataValue();
        //Message.printStatus(2, "", "Checking value " + tsvalue + " at " + data.getDate() + " for repeat." );
        // Skip over missing
        if ( ts.isDataMissing(tsvalue) ) {
            continue;
        }
        // Look forward while values are the same.  Afterwards, deal with the sequence.
        date2 = data.getDate();
        tsi2.setBeginTime( date2 );
        // Advance one so as to start comparison with value after...
        tsi2.next();
        countConditionMet = 0;
        startToAdjust = null;
        endToAdjust = null;
        while ( (data2 = tsi2.next()) != null ) {
            tsvalue2 = data2.getDataValue();
            if ( tsvalue == tsvalue2 ) {
                ++countConditionMet;
                if ( countConditionMet >= value1m1 ) {
                    // Save the first "offending" date/time that will need adjusting
                    if ( startToAdjust == null ) {
                        startToAdjust = new DateTime(data2.getDate());
                    }
                    // Also save the last "offending" date/time that will need adjusting
                    endToAdjust = new DateTime(data2.getDate());
                }
            }
            else {
                // No more matching values - break and take necessary action below
                break;
            }
        }
        // Now evaluate the number of matching values...
        // A parameter of Value1=2 means that 2 repeating values triggers the response to the check,
        // for the 2nd+ values
        if ( countConditionMet >= value1m1 ) {
            // Take action on the offending values and reset the main iterator to start after the adjusted
            // sequence
            // If an action is required, do it
            tsi3.setBeginTime(startToAdjust);
            tsi3.setEndTime(endToAdjust);
            int count = value1m1;
            while ( (data2 = tsi3.next()) != null ) {
                date2 = data2.getDate();
                tsvalue2 = data2.getDataValue();
                ++count;
                message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue2,tsValueFormat)
                + " at " + date2 + " repeated (occurrence: " + count + ").";
                // Add to the problems list
                __problems.add ( message );
                if ( __flag != null ) {
                    // Update the flag value
                    dataPoint = ts.getDataPoint(date2, dataPoint );
                    dataPoint.setDataFlag ( __flag );
                    ts.setDataValue(date2, dataPoint.getDataValue(), dataPoint.getDataFlag(), dataPoint.getDuration() );
                }
                if ( __action != null )  {
                    if ( __action.equalsIgnoreCase("Remove") ) {
                        if ( ts instanceof IrregularTS ) {
                            // Remove the data point from memory
                            ((IrregularTS)ts).removeDataPoint(date2);
                        }
                        else {
                            // Set to missing
                            ts.setDataValue(date2, ts.getMissing() );
                        }
                    }
                    else if ( __action.equalsIgnoreCase("SetMissing") ) {
                        ts.setDataValue(date2, ts.getMissing() );
                    }
                }
            }
            // Advance the main iterator to start checking the next value after the sequence
            tsi.setBeginTime(endToAdjust);
            tsi.next(); // Will return the new begin time
        }
        else {
            // No conditions met.  No action taken.
            // Just advance the iterator and check the next sequence.
        }
    }
    // Final data annotations based on full count of matches.
    if ( (__flag != null) && !__flag.equals("") && (__problems.size() > 0) ) {
        // Remove leading + on flag, used to indicate concatenation
        String flag = StringUtil.remove(__flag,"+");
        if ( (__flagDesc == null) || __flagDesc.equals("") ) {
            // Default description...
            message = "Detected " + __problems.size() + " values where " + formatCriteriaForFlagDesc() + ".";
            ts.addDataFlagMetadata(new TSDataFlagMetadata( flag, message));
        }
        else {
            // Use supplied description...
            message = "Detected " + __problems.size() + " values where " + __flagDesc + ".";
            ts.addDataFlagMetadata(new TSDataFlagMetadata( flag, message));
        }
        // Add a message to the genesis since flags have been set...
        ts.addToGenesis ( message + "  Set flag to " + __flag + "." );
    }
}

/**
Format the criteria for use in output.
@return a string that describes the criteria, suitable for the flag description.
*/
private String formatCriteriaForFlagDesc ()
{
    if ( __checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN ) {
        return "abs(change(value)) > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN ) {
        return "percent(abs(change(value))) > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.CHANGE_GREATER_THAN ) {
        return "change(value) > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.CHANGE_LESS_THAN ) {
        return "change(value) < " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.IN_RANGE ) {
        return StringUtil.formatString(__checkValue1,"%.6f") + " <= value <= " +
            StringUtil.formatString(__checkValue2,"%.6f");
    }
    else if ( __checkCriteria == CheckType.OUT_OF_RANGE ) {
        return "value < " + StringUtil.formatString(__checkValue1,"%.6f") + " OR value > " +
        StringUtil.formatString(__checkValue2,"%.6f");
    }
    else if ( __checkCriteria == CheckType.MISSING ) {
        return "value is missing";
    }
    else if ( __checkCriteria == CheckType.REPEAT ) {
        return "value repeats previous value";
    }
    else if ( __checkCriteria == CheckType.LESS_THAN ) {
        return "value < " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO ) {
        return "value <= " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.GREATER_THAN ) {
        return "value > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO ) {
        return "value >= " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.EQUAL_TO ) {
        return "value = " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else {
        throw new InvalidParameterException ( "Unrecognized check criteria \"" + __checkCriteria + "\"" );
    }
}

/**
Return the analysis end date/time.
@return the analysis end date/time.
*/
public DateTime getAnalysisEnd ()
{
    return __analysisEnd;
}

/**
Return the analysis start date/time.
@return the analysis start date/time.
*/
public DateTime getAnalysisStart ()
{
    return __analysisStart;
}

/**
Return the check type.
@return the check type.
*/
public CheckType getCheckCriteria ()
{
    return __checkCriteria;
}

/**
Get the list of check types that can be performed.
*/
public static List<CheckType> getCheckCriteriaChoices()
{
    List<CheckType> choices = new Vector();
    choices.add ( CheckType.ABS_CHANGE_GREATER_THAN );
    choices.add ( CheckType.ABS_CHANGE_PERCENT_GREATER_THAN );
    choices.add ( CheckType.CHANGE_GREATER_THAN );
    choices.add ( CheckType.CHANGE_LESS_THAN );
    choices.add ( CheckType.IN_RANGE );
    choices.add ( CheckType.OUT_OF_RANGE );
    choices.add ( CheckType.MISSING );
    choices.add ( CheckType.REPEAT );
    choices.add ( CheckType.LESS_THAN );
    choices.add ( CheckType.LESS_THAN_OR_EQUAL_TO );
    choices.add ( CheckType.GREATER_THAN );
    choices.add ( CheckType.GREATER_THAN_OR_EQUAL_TO );
    choices.add ( CheckType.EQUAL_TO );
    return choices;
}

/**
Get the list of statistics that can be performed.
@return the statistic display names as strings.
*/
public static List<String> getCheckCriteriaChoicesAsStrings()
{
    List<CheckType> choices = getCheckCriteriaChoices();
    List<String> stringChoices = new ArrayList<String>();
    for ( int i = 0; i < choices.size(); i++ ) {
        stringChoices.add ( "" + choices.get(i) );
    }
    return stringChoices;
}

/**
Return the number of values where the check criteria was met.
*/
public int getCheckCriteriaMetCount()
{
	return __checkCriteriaMetCount;
}

/**
Return the number of values that are required to evaluate a criteria.
@return the number of values that are required to evaluate a criteria.
@param checkCriteria the check criteria that is being evaluated.
*/
public static int getRequiredNumberOfValuesForCheckCriteria ( CheckType checkCriteria )
{
    // TODO SAM 2009-04-23 Need to convert to enumeration or something other than simple strings
    if ( checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.CHANGE_GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.CHANGE_LESS_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.EQUAL_TO ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.IN_RANGE ) {
        return 2;
    }
    else if ( checkCriteria == CheckType.LESS_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.MISSING ) {
        return 0;
    }
    else if ( checkCriteria == CheckType.OUT_OF_RANGE ) {
        return 2;
    }
    else if ( checkCriteria == CheckType.REPEAT ) {
        return 1;
    }
    else {
        String message = "Requested criteria is not recognized: " + checkCriteria;
        String routine = "TSUtil_CheckTimeSeries.getRequiredNumberOfValuesForCheckCriteria";
        Message.printWarning(3, routine, message);
        throw new InvalidParameterException ( message );
    }
}

/**
Return a list of problems for the time series.
*/
public List<String> getProblems ()
{
    return __problems;
}

/**
Return the time series being analyzed.
@return the time series being analyzed.
*/
public TS getTimeSeries ()
{
    return __ts;
}

/**
Return the first check constraint value.
@return the first check constraint value
*/
public Double getCheckValue1 ()
{
    return __checkValue1;
}

/**
Return the second check constraint value
@return the second check constraint value
*/
public Double getCheckValue2 ()
{
    return __checkValue2;
}

}