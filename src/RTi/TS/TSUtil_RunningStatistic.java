// TSUtil_RunningStatistic - create a new time series that is a running statistic of values from the input time series.

/* NoticeStart

CDSS Common Java Library
CDSS Common Java Library is a part of Colorado's Decision Support Systems (CDSS)
Copyright (C) 1994-2022 Colorado Department of Natural Resources

CDSS Common Java Library is free software:  you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CDSS Common Java Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CDSS Common Java Library.  If not, see <https://www.gnu.org/licenses/>.

NoticeEnd */

package RTi.TS;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;

import RTi.Util.Math.DistributionType;
import RTi.Util.Math.MathUtil;
import RTi.Util.Math.SortOrderType;
import RTi.Util.Message.Message;
import RTi.Util.Time.DateTime;
import RTi.Util.Time.TimeInterval;
import RTi.Util.Time.TimeUtil;

/**
Create a new time series that is a running statistic of values from the input time series.
*/
public class TSUtil_RunningStatistic
{
    
/**
Time series to process.
*/
private TS __ts = null;

/**
Analysis start.
*/
private DateTime __analysisStart = null;

/**
Analysis end.
*/
private DateTime __analysisEnd = null;

/**
Normal start.
*/
private DateTime __normalStart = null;

/**
Normal end.
*/
private DateTime __normalEnd = null;

/**
Output start.
*/
private DateTime __outputStart = null;

/**
Output end.
*/
private DateTime __outputEnd = null;

/**
Sample type.
*/
private RunningAverageType __sampleType = null;

/**
Statistic.
*/
private TSStatisticType __statistic = null;

/**
Bracket (N) for N-year running statistic, as per the running average type.
*/
private int __n;

/**
Bracket (N) for N-year running statistic, as per the running average type, by month.
This will override the singular value.  If any value is null, skip the month in calculating the statistic.
*/
private Integer [] __nByMonth = null;

/**
Custom bracket (N) for N-year running statistic, as per the running average type, by month.
This will override the singular value and month values.
The dimension will be [12][2] where [][0] is the first offset and [][1] is the second offset for the range.
If any row is null, skip the month in calculating the statistic.
*/
private Integer [][] __nCustomByMonth = null;

/**
Number of missing values allowed in the sample.
*/
private int __allowMissingCount;

/**
Minimum sample size to do a calculation.
*/
private int __minimumSampleSize;

/**
Distribution.
*/
private DistributionType __distribution = null;

/**
Distribution parameters.
*/
private Hashtable<String,String> __distributionParameters = null;

/**
Units to use for probabilities, "Fraction", "Percent", or "%".
*/
private String __probabilityUnits = "Fraction"; // Default.

/**
Sort order type.
*/
private SortOrderType __sortOrderType = null;

/**
List of problems generated by this command, guaranteed to be non-null.
*/
private List<String> __problems = new ArrayList<>();

/**
Construct the object and check for valid input.
@param ts regular-interval time series for which to create the running average time series
@param n N for N-year running statistic and otherwise the bracket for centered,
previous, and future running statistics
@param nByMonth same as "n" but 12 values, one for each month (Jan,Feb,...,Dec)
@param nCustomByMonth same as "n" but 12 ranges with start and start offset
@param statisticType statistic to compute
@param sampleType type of data sampling for statistic
@param allowMissingCount the number of values allowed to be missing in the sample (for example can set to 5 for
30-year running average to limit impacts of occasional missing data)
@param minimumSampleSize for sample methods that don't specify the sample size (like NYear), specify the minimum sample
size to do the calculation, or -1 if the sample size does not matter
@param distributionType distribution type (used with Rank, PlottingPosition, *Exceedance*
@param distributionParameters parameters used by distribution, e.g., coefficients 
@param probabilityUnits units to use for probability statistics ("Fraction", "Percent", or "%" - default is "Fraction").
@param sortOrderType sort order type needed by some statistics (e.g. Rank, PlottingPosition, *Exceedance*)
@param normalStart date/time for start of normal period
@param normalEnd date/time for end of normal period
@param outputStart date/time for start of output time series
@param outputEnd date/time for end of output time series
*/
public TSUtil_RunningStatistic ( TS ts, int n, Integer [] nByMonth, Integer [][] nCustomByMonth,
	TSStatisticType statisticType,
	DateTime analysisStart, DateTime analysisEnd,
    RunningAverageType sampleType,
    int allowMissingCount, int minimumSampleSize, DistributionType distributionType,
    Hashtable<String,String> distributionParameters, String probabilityUnits, SortOrderType sortOrderType,
    DateTime normalStart, DateTime normalEnd, DateTime outputStart, DateTime outputEnd )
{   String message;
    String routine = getClass().getName();

    if ( ts == null ) {
        message = "Input time series is null.";
        Message.printWarning ( 2, routine, message );
        throw new InvalidParameterException ( message );
    }
    
    if ( ts.getDataIntervalBase() == TimeInterval.IRREGULAR ) {
        message = "Converting irregular time series to running statistic is not supported.";
        Message.printWarning ( 2, routine, message );
        throw new IrregularTimeSeriesNotSupportedException ( message );
    }

    boolean found = false;
    for ( TSStatisticType s : getStatisticChoices() ) {
        if ( s == statisticType ) {
            found = true;
            break;
        }
    }
    if ( !found ) {
        message = "Statistic \"" + statisticType + "\" is not supported.";
        Message.printWarning ( 2, routine, message );
        throw new InvalidParameterException ( message );
    }
 
    found = false;
    for ( DistributionType d : getDistributionChoices() ) {
        if ( d == distributionType ) {
            found = true;
            break;
        }
    }
    if ( !found ) {
        message = "Distribution \"" + distributionType + "\" is not supported.";
        Message.printWarning ( 2, routine, message );
        throw new InvalidParameterException ( message );
    }
    else {
        if ( distributionType == DistributionType.GRINGORTEN ) {
            if ( (distributionParameters == null) || (distributionParameters.get("a") == null) ) {
                message = "Distribution " + DistributionType.GRINGORTEN +
                    " requires that the coefficent \"a\" is specified in distribution parameters.";
                Message.printWarning ( 2, routine, message );
                throw new InvalidParameterException ( message );
            }
        }
    }
    // TODO SAM 2013-12-17 The low level code currently deals with this
    // Make sure exceedance and nonexceedance probabilities are sorting the right way
    //if ( (statisticType == TSStatisticType.EXCEEDANCE_PROBABILITY) || (statisticType == TSStatisticType.NONEXCEEDANCE_PROBABILITY) ) {
    //    if ( (sortOrderType != null) && (sortOrderType != SortOrderType.HIGH_TO_LOW) ) {
    //        message = "Statistic " + statisticType +
    //            " internally specifies the sort order as " + SortOrderType.HIGH_TO_LOW + " which is different from the requested sort order";
    //        Message.printWarning ( 2, routine, message );
    //    }
    //}
    
    setAnalysisStart(analysisStart);
    setAnalysisEnd(analysisEnd);
    
    setNormalStart(normalStart);
    setNormalEnd(normalEnd);
    
    if ( (normalStart != null) && (normalEnd != null) && (sampleType != RunningAverageType.ALL_YEARS) ) {
        message = "If normal period is specified, the sample type type must be " + RunningAverageType.ALL_YEARS +
            " (" + sampleType + " is specified).";
        Message.printWarning ( 2, routine, message );
        throw new InvalidParameterException ( message );
    }
    
    setOutputStart(outputStart);
    setOutputEnd(outputEnd);
    
    found = false;
    for ( RunningAverageType t : getRunningAverageTypeChoices() ) {
        if ( t == sampleType ) {
            found = true;
            break;
        }
    }
    if ( !found ) {
        message = "Sample type type \"" + sampleType + "\" is not supported.";
        Message.printWarning ( 2, routine, message );
        throw new InvalidParameterException ( message );
    }
    
    setTS ( ts );
    setN ( n );
    setNByMonth ( nByMonth );
    setNCustomByMonth ( nCustomByMonth );
    setStatisticType ( statisticType );
    setDistributionType ( distributionType );
    setDistributionParameters ( distributionParameters );
    setSortOrderType ( sortOrderType );
    setSampleType ( sampleType );
    setAllowMissingCount ( allowMissingCount );
    setMinimumSampleSize ( minimumSampleSize );
    if ( (probabilityUnits == null) || probabilityUnits.equals("") ) {
        probabilityUnits = "Fraction";
    }
    if ( (probabilityUnits.equalsIgnoreCase("Fraction") ||
        probabilityUnits.equalsIgnoreCase("Percent") || probabilityUnits.equals("%")) ) {
        // Only override default of Fraction if recognized units.
        setProbabilityUnits ( probabilityUnits );
    }
    else {
        message = "Probability units \"" + probabilityUnits + "\" is not supported.";
        Message.printWarning ( 2, routine, message );
        throw new InvalidParameterException ( message );
    }
}

/**
Return the offset data for a month.
This indicates the interval offsets needed to position the date/time around the current date/time.
@return offset data as array { offset1, offset2, neededCount } or null if monthly values and the month n is null.
*/
public int [] calculateOffsetData ( RunningAverageType sampleType, int month, int n,
	Integer [] nByMonth, boolean doNByMonth, Integer [][] nCustomByMonth, boolean doNCustomByMonth, TS newts ) 
{
	int [] offsetData = new int[3];
	offsetData[0] = 0; // offset1
	offsetData[1] = 0; // offset2
	offsetData[2] = 0; // neededCount
	int month0 = month - 1; // Position in zero index array.
	if ( doNByMonth ) {
		// Reset N for the monthly value.
		if ( nByMonth[month0] == null ) {
			return null;
		}
		n = nByMonth[month0];
	}
	else if ( doNCustomByMonth ) {
		if ( (nCustomByMonth[month0][0] == null) || (nCustomByMonth[month0][1] == null)) {
			return null;
		}
		else {
			offsetData[0] = nCustomByMonth[month0][0];
			offsetData[1] = nCustomByMonth[month0][1];
			offsetData[2] = offsetData[1] - offsetData[0] + 1;
			return offsetData;
		}
	}
    if ( sampleType == RunningAverageType.ALL_YEARS ) {
    }
    else if ( sampleType == RunningAverageType.N_ALL_YEAR ) {
    	offsetData[2] = newts.getDate2().getYear() - newts.getDate1().getYear() + 1;
    }
    else if ( sampleType == RunningAverageType.CENTERED ) {
    	// Offset is on each side.
        offsetData[0] = -1*n;
        offsetData[1] = n;
        offsetData[2] = n*2 + 1;
    }
    else if ( sampleType == RunningAverageType.FUTURE ) {
        // Offset brackets the date.
    	offsetData[0] = 1;
    	offsetData[1] = n;
    	offsetData[2] = n;
    }
    else if ( sampleType == RunningAverageType.FUTURE_INCLUSIVE ) {
        // Offset brackets the date.
    	offsetData[0] = 0;
    	offsetData[1] = n;
    	offsetData[2] = n + 1;
    }
    else if ( sampleType == RunningAverageType.NYEAR ) {
        // Offset is to the left but remember to include the time step itself.
    	offsetData[0] = -1*(n - 1);
    	offsetData[1] = 0;
    	offsetData[2] = n;
    }
    else if ( sampleType == RunningAverageType.PREVIOUS ) {
        // Offset brackets the date.
    	offsetData[0] = -n;
    	offsetData[1] = -1;
    	offsetData[2] = n;
    }
    else if ( sampleType == RunningAverageType.PREVIOUS_INCLUSIVE ) {
        // Offset brackets the date.
    	offsetData[0] = -n;
    	offsetData[1] = 0;
    	offsetData[2] = n + 1;
    }
    return offsetData;
}

/**
Return the number of allowed missing values in the sample.
*/
public int getAllowMissingCount () {
    return __allowMissingCount;
}

/**
Return the analysis end.
*/
public DateTime getAnalysisEnd () {
    return __analysisEnd;
}

/**
Return the analysis start.
*/
public DateTime getAnalysisStart () {
    return __analysisStart;
}

/**
Get the list of distributions that can be used in calculations.
*/
public static List<DistributionType> getDistributionChoices() {
    // Enable statistics that illustrate how things change over time.
    List<DistributionType> choices = new ArrayList<>();
    choices.add ( DistributionType.GRINGORTEN );
    choices.add ( DistributionType.WEIBULL );
    return choices;
}

/**
Get the list of distributions that can be calculated.
@return the distribution display names as strings.
*/
public static List<String> getDistributionChoicesAsStrings() {
    List<DistributionType> choices = getDistributionChoices();
    List<String> stringChoices = new ArrayList<>();
    for ( int i = 0; i < choices.size(); i++ ) {
        stringChoices.add ( "" + choices.get(i) );
    }
    return stringChoices;
}

/**
Return the distribution parameters.
*/
public Hashtable<String,String> getDistributionParameters () {
    return __distributionParameters;
}

/**
Return the distribution type.
*/
public DistributionType getDistributionType () {
    return __distribution;
}

/**
Return the minimum sample size.
*/
public int getMinimumSampleSize () {
    return __minimumSampleSize;
}

/**
Return the N-year N or bracket.
*/
public int getN () {
    return __n;
}

/**
Return the N-year N or bracket (monthly array).
*/
public Integer [] getNByMonth () {
    return __nByMonth;
}

/**
Return the custom N-year N or bracket (monthly array).
*/
public Integer [][] getNCustomByMonth () {
    return __nCustomByMonth;
}

/**
Return the normal end.
*/
public DateTime getNormalEnd () {
    return __normalEnd;
}

/**
Return the normal start.
*/
public DateTime getNormalStart () {
    return __normalStart;
}

/**
Return the output end.
*/
public DateTime getOutputEnd () {
    return __outputEnd;
}

/**
Return the output start.
*/
public DateTime getOutputStart () {
    return __outputStart;
}

/**
Return the probability units.
*/
public String getProbabilityUnits () {
    return __probabilityUnits;
}

/**
Return a list of problems for the time series.
*/
public List<String> getProblems () {
    return __problems;
}

/**
Return the running statistic sample types that are supported by the class.
*/
public static RunningAverageType[] getRunningAverageTypeChoices () {
    RunningAverageType[] types = {
        RunningAverageType.ALL_YEARS,
        RunningAverageType.CENTERED,
        RunningAverageType.CUSTOM,
        RunningAverageType.FUTURE,
        RunningAverageType.FUTURE_INCLUSIVE,
        RunningAverageType.NYEAR,
        RunningAverageType.N_ALL_YEAR,
        RunningAverageType.PREVIOUS,
        RunningAverageType.PREVIOUS_INCLUSIVE
    };
    return types;
}

/**
Return the sample window type.
*/
public RunningAverageType getSampleType () {
    return __sampleType;
}

/**
Return the sort order type.
*/
public SortOrderType getSortOrderType () {
    return __sortOrderType;
}

/**
Get the list of statistics that can be performed.
These are primary statistics types; however, other data may be needed to fully describe the statistic.  For example,
Rank and PlottingPosition depend on the sort order and PlottingPosition depends on the distribution.  Consequently,
other code must enforce these properties and provide transparency to users.
*/
public static List<TSStatisticType> getStatisticChoices() {
    // Enable statistics that illustrate how things change over time.
    List<TSStatisticType> choices = new ArrayList<>();
    choices.add ( TSStatisticType.CHANGE );
    choices.add ( TSStatisticType.CHANGE_ABS );
    choices.add ( TSStatisticType.CHANGE_FRACTION );
    choices.add ( TSStatisticType.CHANGE_FRACTION_ABS );
    choices.add ( TSStatisticType.CHANGE_PERCENT );
    choices.add ( TSStatisticType.CHANGE_PERCENT_ABS );
    choices.add ( TSStatisticType.EXCEEDANCE_PROBABILITY );
    choices.add ( TSStatisticType.GEOMETRIC_MEAN );
    choices.add ( TSStatisticType.LAG1_AUTO_CORRELATION );
    choices.add ( TSStatisticType.MAX );
    choices.add ( TSStatisticType.MEAN );
    choices.add ( TSStatisticType.MEDIAN );
    choices.add ( TSStatisticType.MIN );
    choices.add ( TSStatisticType.NEW_MAX );
    choices.add ( TSStatisticType.NEW_MIN );
    choices.add ( TSStatisticType.NONEXCEEDANCE_PROBABILITY );
    choices.add ( TSStatisticType.PERCENT_OF_MAX );
    choices.add ( TSStatisticType.PERCENT_OF_MEDIAN );
    choices.add ( TSStatisticType.PERCENT_OF_MEAN );
    choices.add ( TSStatisticType.PERCENT_OF_MIN );
    choices.add ( TSStatisticType.PLOTTING_POSITION );
    choices.add ( TSStatisticType.RANK);
    choices.add ( TSStatisticType.SKEW );
    choices.add ( TSStatisticType.STD_DEV );
    choices.add ( TSStatisticType.TOTAL );
    choices.add ( TSStatisticType.VARIANCE );
    return choices;
}

/**
Get the list of statistics that can be calculated.
@return the statistic display names as strings.
*/
public static List<String> getStatisticChoicesAsStrings() {
    List<TSStatisticType> choices = getStatisticChoices();
    List<String> stringChoices = new ArrayList<>();
    for ( int i = 0; i < choices.size(); i++ ) {
        stringChoices.add ( "" + choices.get(i) );
    }
    return stringChoices;
}

/**
Return the running statistic type.
*/
public TSStatisticType getStatisticType () {
    return __statistic;
}

/**
Return the input time series being processed.
*/
public TS getTS () {
    return __ts;
}
    
/**
Create a running average time series where the time series value is the
average of 1 or more values from the original time series.  The description is
appended with ", centered [N] running average" or ", N-year running average", etc.
@return The new running statistic time series, which is a copy of the original metadata
but with data being the running statistic.
@exception RTi.TS.TSException if there is a problem creating and filling the new time series.
*/
public TS runningStatistic ( boolean createData )
throws TSException, IrregularTimeSeriesNotSupportedException
{   String genesis = "", message, routine = getClass().getSimpleName() + ".runningStatistic";
    TS newts = null;
    TS newts2 = null; // Used when normal period is used (newts is statistic for normal period, newts2 is final output).

    TS ts = getTS();
    TSStatisticType statisticType = getStatisticType();
    DistributionType distributionType = getDistributionType();
    Hashtable<String,String> distributionParameters = getDistributionParameters();
    SortOrderType sortOrderType = getSortOrderType();
    DateTime analysisStart = getAnalysisStart();
    DateTime analysisEnd = getAnalysisEnd();
    DateTime normalStart = getNormalStart();
    DateTime normalEnd = getNormalEnd();
    DateTime outputStart = getOutputStart();
    DateTime outputEnd = getOutputEnd();
    RunningAverageType sampleType = getSampleType();
    int n = getN();
    Integer [] nByMonth = getNByMonth();
    Integer [][] nCustomByMonth = getNCustomByMonth();
    boolean doNByMonth = false;
    boolean doNCustomByMonth = false;
    if ( (nByMonth != null) && (nByMonth.length == 12) ) {
    	doNByMonth = true;
    }
    if ( (nCustomByMonth != null) && (nCustomByMonth.length == 12) ) {
    	doNByMonth = false;
    	doNCustomByMonth = true;
    }
    int allowMissingCount = getAllowMissingCount();
    int minimumSampleSize = getMinimumSampleSize();
    if ( minimumSampleSize <= 0 ) {
        // Not specified so require at least 1 value, mainly to keep the analysis going.
        minimumSampleSize = 1;
    }

    // Set the data type in the new time series to reflect the running statistic.
    String statString = "" + statisticType;
    if ( sampleType == RunningAverageType.NYEAR ) {
        statString = "" + n + statisticType;
    }
    /* TODO SAM 2013-09-13 Why is this here?  Does not make sense for all the new statistics.
    if ( (sampleType != RunningAverageType.N_ALL_YEAR) && (sampleType != RunningAverageType.ALL_YEARS) && (n == 0) ) {
        // NoReturn a copy of the original time series
        //
        newts = (TS)ts.clone();
        newts.setDataType(ts.getDataType() + "-Running-" + statString );
        return newts;
    }
    */

    // Initialize handling of specific statistics.

    // Some statistics are a manipulation of a "normal period" statistic.
    // For example, "PercentOfMean" requires an initial statistic (Mean) to be calculated
    // for the normal period and then the input time series value is used to compute the final statistic.
    // Use statisticTypeForNormal to save the final statistic.  The process is as follows:
    // 1) Compute the statistic for the normal period (may be the same as the analysis period)
    // 2) Use the results from 1 to compute the output for the analysis period
    int intervalBase = ts.getDataIntervalBase();
    int intervalMult = ts.getDataIntervalMult();
    TSStatisticType statisticTypeForNormal = null;
    double unitsMult = 1.0; // Used for probability conversion from fraction.
    String newUnits = null;
   	boolean doIncludeMissingInSample = false; // Used below to set to true if CHANGE statistics, but generally false>
    // Calculated statistic for period, for each day, used for RunningAverageType.N_ALL_YEARS and SampleFilter="MatchDay".
    Hashtable<String,Double> statisticForPeriodByInterval = new Hashtable<>();
    if ( (statisticType == TSStatisticType.CHANGE) ||
    	(statisticType == TSStatisticType.CHANGE_ABS) ||
    	(statisticType == TSStatisticType.CHANGE_PERCENT) ||
    	(statisticType == TSStatisticType.CHANGE_PERCENT_ABS) ) {
    	// Need to include missing in sample because end points are used for calculation.
    	doIncludeMissingInSample = true;
    }
    else if ( (statisticType == TSStatisticType.LAG1_AUTO_CORRELATION) ||
        (statisticType == TSStatisticType.PLOTTING_POSITION) ||
        (statisticType == TSStatisticType.RANK) ||
        (statisticType == TSStatisticType.SKEW) ) {
        newUnits = "";
    }
    else if (
        (statisticType == TSStatisticType.NEW_MAX) ||
        (statisticType == TSStatisticType.NEW_MIN) ) {
    	// Initialize the hashtable to store statistic for each day:
    	// - use leap year 2020 to ensure Feb 29 is included
    	DateTime dt = null;
    	DateTime dtEnd = null;
    	if ( ts.getDataIntervalBase() == TimeInterval.DAY ) {
    		dt = DateTime.parse("2020-01-01");
    		dtEnd = DateTime.parse("2020-12-31");
    	}
    	else if ( ts.getDataIntervalBase() == TimeInterval.MONTH ) {
    		dt = DateTime.parse("2020-01");
    		dtEnd = DateTime.parse("2020-12");
    	}
   		statisticForPeriodByInterval = new Hashtable<>();
   		String key = null;
    	for ( ; dt.lessThanOrEqualTo(dtEnd); dt.addInterval(intervalBase,intervalMult) ) {
    		if ( ts.getDataIntervalBase() == TimeInterval.DAY ) {
    			key = String.format("%02d%02d", dt.getMonth(), dt.getDay() );
    		}
    		else if ( ts.getDataIntervalBase() == TimeInterval.MONTH ) {
    			key = String.format("%02d", dt.getMonth() );
    		}
    		statisticForPeriodByInterval.put(key, Double.valueOf(Double.NaN));
    	}
    }
    else if (
        (statisticType == TSStatisticType.EXCEEDANCE_PROBABILITY) ||
        (statisticType == TSStatisticType.NONEXCEEDANCE_PROBABILITY) ) {
        newUnits = getProbabilityUnits();
        if ( newUnits.equalsIgnoreCase("Percent") || newUnits.equalsIgnoreCase("%") ) {
            // Conversion from fraction to percent.
            unitsMult = 100.0;
        }
    }
    else if (
        (statisticType == TSStatisticType.PERCENT_OF_MEAN) ||
        (statisticType == TSStatisticType.PERCENT_OF_MEDIAN) ||
        (statisticType == TSStatisticType.PERCENT_OF_MAX) ||
        (statisticType == TSStatisticType.PERCENT_OF_MIN) ) {
        newUnits = "Percent";
        statisticTypeForNormal = statisticType; // Assign to original requested statistic.
        // Reset the statistic type to calculate the first statistic time series.
        if ( statisticType == TSStatisticType.PERCENT_OF_MEAN ) {
            statisticType = TSStatisticType.MEAN;
        }
        else if ( statisticType == TSStatisticType.PERCENT_OF_MEDIAN ) {
            statisticType = TSStatisticType.MEDIAN;
        }
        else if ( statisticType == TSStatisticType.PERCENT_OF_MAX ) {
            statisticType = TSStatisticType.MAX;
        }
        else if ( statisticType == TSStatisticType.PERCENT_OF_MIN ) {
            statisticType = TSStatisticType.MIN;
        }
    }
    else if ( statisticType == TSStatisticType.VARIANCE ) {
        String units = ts.getDataUnits();
        newUnits = units + "^2";
    }
    
    // Create a new time series of the proper type.

    String newInterval = "" + intervalMult + TimeInterval.getName(intervalBase,1);
    try {
        newts = TSUtil.newTimeSeries ( newInterval, false );
        if ( statisticTypeForNormal != null ) {
            newts2 = TSUtil.newTimeSeries ( newInterval, false );
        }
    }
    catch ( Exception e ) {
        message = "Unable to create new time series of interval \"" + newInterval + "\"";
        Message.printWarning ( 3, routine, message );
        throw new RuntimeException ( message );
    }
    newts.copyHeader ( ts );
    newts.setDataType(ts.getDataType() + "-Running-" + statString );
    // If the output period is not specified, use the full time series period.
    if ( outputStart == null ) {
        outputStart = new DateTime(ts.getDate1());
    }
    newts.setDate1 ( outputStart );
    if ( outputEnd == null ) {
        outputEnd = new DateTime(ts.getDate2());
    }
    newts.setDate2 ( outputEnd );
    if ( newUnits != null ) {
        newts.setDataUnits ( newUnits );
    }
    if ( statisticTypeForNormal != null ) {
        // Initial calculation.
        newts.setDate1(normalStart);
        newts.setDate2(normalEnd);
        // Final output.
        newts2.copyHeader(ts); // Includes units.
        newts2.setDataType(ts.getDataType() + "-Running-" + statString );
        newts2.setDate1 ( outputStart );
        newts2.setDate2 ( outputEnd );
        if ( newUnits != null ) {
            newts2.setDataUnits ( newUnits );
        }
    }
    // Set the analysis period to the output end if not specified.
    // Have to do here because output start may be determine from the time series.
    if ( analysisStart == null ) {
        analysisStart = new DateTime(outputStart);
    }
    if ( analysisEnd == null ) {
        analysisEnd = new DateTime(outputEnd);
    }
    // Make an additional adjustment to the normal period.
    if ( (statisticType == TSStatisticType.PERCENT_OF_MEAN) ||
        (statisticType == TSStatisticType.PERCENT_OF_MEDIAN) ||
        (statisticType == TSStatisticType.PERCENT_OF_MAX) ||
        (statisticType == TSStatisticType.PERCENT_OF_MIN) ) {
        String note1 = "", note2 = "";
        if ( normalStart == null ) {
        	normalStart = new DateTime(analysisStart);
        	note1 = " (set to AnalysisStart)";
        }
        if ( normalEnd == null ) {
        	normalEnd = new DateTime(analysisEnd);
        	note2 = " (set to AnalysisEnd)";
        }
        Message.printStatus(2,routine,"Will compute " + statisticType +
            " statistic first as input to final " + statisticTypeForNormal + " statistic using normal period " +
            normalStart + note1 + " to " + normalEnd + note2 );	
    }
    int neededCountWithAllowMissing = 0; // Needed count adjusted for allowed missing.
    if ( createData ) {
        // Actually create the data (otherwise only the header information is populated).
        newts.allocateDataSpace();
        if ( statisticTypeForNormal != null ) {
            newts2.allocateDataSpace();
        }
    
        // Set the offsets for getting data around the current date/time.
    
        int neededCount = 0; // Used initially to size the sample array.
        int offset1 = 0;
        int offset2 = 0;
        if ( !doNByMonth && !doNCustomByMonth) {
        	// Calculate offsets for the constant N.
        	int [] offsetData0 = calculateOffsetData ( sampleType, 0, n, nByMonth, doNByMonth, nCustomByMonth, doNCustomByMonth, newts );
        	offset1 = offsetData0[0];
        	offset2 = offsetData0[1];
        	neededCount = offsetData0[2];
        }
        int neededCountMax = neededCount;
        StringBuilder genesisMonth = null;
        if ( doNByMonth || doNCustomByMonth ) {
        	// Calculate the maximum neededCount, to size the sample data array.
        	genesisMonth = new StringBuilder();
        	boolean initialized = false;
        	for ( int i = 1; i <= 12; i++ ) {
        		int [] offsetData0 = calculateOffsetData ( sampleType, i, 0, nByMonth, doNByMonth, nCustomByMonth, doNCustomByMonth, newts );
        		if ( offsetData0 != null ) {
	        		if ( !initialized ) {
	        			neededCountMax = offsetData0[2];
	        			initialized = true;
	        		}
	        		else if ( offsetData0[2] > neededCountMax ) {
	        			neededCountMax = offsetData0[2];
	        		}
        		}
        		// Build the genesis string.
        		if ( i >= 2 ) {
        			genesisMonth.append(",");
        		}
        		if ( doNByMonth ) {
	        		if ( nByMonth[i-1] == null ) {
	        			genesisMonth.append("");
	        		}
	        		else {
	        			genesisMonth.append("" + nByMonth[i-1]);
	        		}
        		}
        		else if ( doNCustomByMonth ) {
	        		if ( (nCustomByMonth[i-1][0] == null) || (nCustomByMonth[i-1][1] == null) ) {
	        			genesisMonth.append("");
	        		}
	        		else {
	        			genesisMonth.append("" + nCustomByMonth[i-1][0] + "-" + nCustomByMonth[i-1][1]);
	        		}
        		}
        	}
        }
        // Set the string for the time series modification history.
        if ( sampleType == RunningAverageType.ALL_YEARS ) {
            genesis = "" + sampleType;
        }
        else if ( sampleType == RunningAverageType.N_ALL_YEAR ) {
            genesis = "NAll-year";
        }
        else if ( sampleType == RunningAverageType.CENTERED ) {
        	if ( doNByMonth ) {
        		genesis = "bracket=" + genesisMonth + " centered";
        	}
        	else {
        		genesis = "bracket=" + n + " centered";
        	}
        }
        else if ( sampleType == RunningAverageType.FUTURE ) {
        	if ( doNByMonth ) {
        		genesis = "bracket=" + genesisMonth + " future (not inclusive)";
        	}
        	else {
        		genesis = "bracket=" + n + " future (not inclusive)";
        	}
        }
        else if ( sampleType == RunningAverageType.FUTURE_INCLUSIVE ) {
        	if ( doNByMonth ) {
        		genesis = "bracket=" + genesisMonth + " future (inclusive)";
        	}
        	else {
        		genesis = "bracket=" + n + " future (inclusive)";
        	}
        }
        else if ( sampleType == RunningAverageType.NYEAR ) {
      		genesis = n + "-year";
        }
        else if ( sampleType == RunningAverageType.PREVIOUS ) {
        	if ( doNByMonth ) {
        		genesis = "bracket=" + genesisMonth + " previous (not inclusive)";
        	}
        	else {
        		genesis = "bracket=" + n + " previous (not inclusive)";
        	}
        }
        else if ( sampleType == RunningAverageType.PREVIOUS_INCLUSIVE ) {
        	if ( doNByMonth ) {
        		genesis = "bracket=" + genesisMonth + " previous (inclusive)";
        	}
        	else {
        		genesis = "bracket=" + n + " previous (inclusive)";
        	}
        }
        
        // Adjusted the number of needed values to allow for missing.
        
        neededCountWithAllowMissing = neededCount;
        if ( allowMissingCount > 0 ) {
            neededCountWithAllowMissing -= allowMissingCount;
        }
        
        // Size the sample array (count will be <= the max and control the calculations).
        // The "count" is used to indicate how big the sample is for calculations.
        double [] sampleArray = new double[neededCountMax];
        // Used for AllYears sample method.  Size for the number of years in the analysis period (will be more than enough).
        // Use the newts date/times because they will match the analysis period or the full period of the original time series.
        DateTime start = new DateTime ( analysisStart );
        DateTime end = new DateTime ( analysisEnd );
        TSData [] sampleArrayTSData; // = new TSData[end.getYear() - start.getYear() + 1];
        
        // Iterate through the full period of the output time series.

        // Analysis period is used for calculations unless normal period is specified.
        // Analysis period is set to output period if not specified.
        if ( statisticTypeForNormal != null ) {
            if ( normalStart != null ) {
                start = new DateTime(normalStart);
            }
            if ( normalEnd != null ) {
                end = new DateTime(normalEnd);
            }
        }
        DateTime date = new DateTime(start);
        DateTime valueDateTime = new DateTime(newts.getDate1());  // Used to access data values for statistic.
        int count, i;
        double value = 0.0;
        double missing = ts.getMissing();
        boolean doCalc = true;
        Hashtable<String,double []> valueCache = new Hashtable<String,double[]>();
        int month;
        int [] offsetData;
        double statisticForPeriod = Double.NaN; // Used when computing long-term statistic, for example NEW_MAX used with N_ALL_YEAR period.
        double statisticForSample = Double.NaN; // Statistic computed from sample, used when decision logic is needed to avoid declaring again.
        boolean haveNewStatisticForSample = false; // Whether a new period statistic needs to be set in the time series.
        for ( ; date.lessThanOrEqualTo( end ); date.addInterval(intervalBase, intervalMult) ) {
            // Initialize the date for looking up values to the initial offset from the loop date (new lines up with old).
            valueDateTime.setDate ( date );
            if ( doNByMonth || doNCustomByMonth ) {
            	// Calculate values needed to compute statistic using monthly N (bracket).
            	month = valueDateTime.getMonth();
            	offsetData = calculateOffsetData ( sampleType, month, n, nByMonth, doNByMonth, nCustomByMonth, doNCustomByMonth, newts );
            	if ( offsetData == null ) {
            		// No offset was specified so don't calculate the output statistic.
            		continue;
            	}
            	offset1 = offsetData[0];
            	offset2 = offsetData[1];
            	neededCount = offsetData[2];
                neededCountWithAllowMissing = neededCount;
                if ( allowMissingCount > 0 ) {
                    neededCountWithAllowMissing -= allowMissingCount;
                }
            }
            // Offset from the current date/time to the start of the bracket.
            if ( sampleType == RunningAverageType.NYEAR ) {
                valueDateTime.addInterval ( TimeInterval.YEAR, offset1 );
            }
            else if ( sampleType == RunningAverageType.N_ALL_YEAR ) {
                // Reset to the start of the period and set the offsets to process the start year to the.
                // current year
                valueDateTime.setYear ( newts.getDate1().getYear() );
                if ( valueDateTime.lessThan(newts.getDate1())) {
                    // Has wrapped around since the first date/time was not the start of a year so add another year.
                    valueDateTime.addYear(1);
                }
                offset1 = valueDateTime.getYear();
                offset2 = date.getYear();
            }
            else {
                valueDateTime.addInterval ( intervalBase, offset1*intervalMult );
            }
            // Get the sample for the calculation.
            count = 0;
            String key = null;
            if ( sampleType == RunningAverageType.ALL_YEARS ) {
                // This will be slow if the values have to be extracted each time.
            	// Because the array will be the same each request, cache at the appropriate time resolution.
            	// For example, if processing annual data, only one array is needed.  If monthly data, 12 arrays are needed.
                // Get the values for all years (false at end means exclude missing).
                if ( intervalBase == TimeInterval.DAY ) {
                    key = "" + date.getMonth() + "-" + date.getDay();
                    sampleArray = valueCache.get(key);
                }
                else if ( intervalBase == TimeInterval.MONTH ) {
                    key = "" + date.getMonth();
                    sampleArray = valueCache.get(key);
                }
                else if ( intervalBase == TimeInterval.YEAR ) {
                    key = "year";
                    sampleArray = valueCache.get(key);
                }
                if ( sampleArray == null ) {
                    // Generate array and save in cache, ignoring missing values.
                	boolean includeMissing = false;
                	if ( doIncludeMissingInSample ) {
                		// For example for CHANGE.
                		includeMissing = true;
                	}
                    sampleArrayTSData = TSUtil.toArrayForDateTime ( ts, start, end, date, includeMissing );
                    if ( sampleArrayTSData == null ) {
                        sampleArrayTSData = new TSData[0];
                    }
                    sampleArray = new double[sampleArrayTSData.length];
                    for ( int is = 0; is < sampleArrayTSData.length; is++ ) {
                        sampleArray[is] = sampleArrayTSData[is].getDataValue();
                        //Message.printStatus(2,routine,"Sample for value date/time " + valueDateTime + " value[" + is + "]=" + sampleArray[is]);
                    }
                    valueCache.put ( key, sampleArray );
                }
                // Reset the count based on the sample array size.
                count = sampleArray.length;
            }
            else {
                // Loop through the intervals in the bracket and get the sample set.
                for ( i = offset1; i <= offset2; i++ ) {
                    // This check should fail harmlessly if dealing with intervals greater than a day.
                    if ( (valueDateTime.getMonth() == 2) && (valueDateTime.getDay() == 29) &&
                        !TimeUtil.isLeapYear(valueDateTime.getYear()) ) {
                        // The Feb 29 that we are requesting in another year does not exist.
                    	// Set to missing This will result in the final output also being missing.
                        value = missing;
                    }
                    else {
                        // Normal data access.
                        value = ts.getDataValue ( valueDateTime );
                    }
                    if ( !ts.isDataMissing(value) ) {
                        // Add the value to the sample (which has been initialized to zero above.
                        sampleArray[count++] = value;
                    }
                    // Reset the dates for the input data value.
                    if ( (sampleType == RunningAverageType.NYEAR) || (sampleType == RunningAverageType.N_ALL_YEAR) ) {
                        // Get the value for the next year (last value will be the current year).
                        valueDateTime.addInterval ( TimeInterval.YEAR, 1 );
                    }
                    else {
                        // Just move forward incrementally between end points.
                        valueDateTime.addInterval ( intervalBase, intervalMult );
                    }
                }
            }
            // Now set the data value to the computed statistic.
            doCalc = false;
            if ( sampleType == RunningAverageType.ALL_YEARS ) {
                if ( count >= minimumSampleSize ) {
                    doCalc = true;
                }
            }
            else if ( sampleType == RunningAverageType.N_ALL_YEAR ) {
                if ( count >= minimumSampleSize ) {
                    doCalc = true;
                }
            }
            else if ( count >= neededCountWithAllowMissing ) {
                if ( count > 0 ) {
                    doCalc = true;
                }
            }
            if ( doCalc ) {
                // Handle the statistics that are supported.
                try {
                    if ( statisticType == TSStatisticType.CHANGE ) {
                    	// Difference between last sample value and first sample value.
                    	if ( count > 0 ) {
                    		if ( !ts.isDataMissing(sampleArray[0]) && !ts.isDataMissing(sampleArray[count - 1]) ) {
                    			value = sampleArray[count - 1] - sampleArray[0];
                    			newts.setDataValue(date,value);
                    		}
                    	}
                    	// Else time series will be missing by default.
                    }
                    else if ( statisticType == TSStatisticType.CHANGE_ABS ) {
                    	// Difference between last sample value and first sample value, absolute.
                    	if ( count > 0 ) {
                    		if ( !ts.isDataMissing(sampleArray[0]) && !ts.isDataMissing(sampleArray[count - 1]) ) {
                    			value = Math.abs(sampleArray[count - 1] - sampleArray[0]);
                    			newts.setDataValue(date,value);
                    		}
                    	}
                    	// Else time series will be missing by default.
                    }
                    else if ( statisticType == TSStatisticType.CHANGE_FRACTION ) {
                    	// Difference between last sample value and first sample value, fraction.
                    	if ( count > 0 ) {
                    		if ( !ts.isDataMissing(sampleArray[0]) && !ts.isDataMissing(sampleArray[count - 1]) ) {
                    			if ( sampleArray[0] != 0 ) {
                    				value = (sampleArray[count - 1] - sampleArray[0])/sampleArray[0];
                    				newts.setDataValue(date,value);
                    			}
                    		}
                    	}
                    	// Else time series will be missing by default.
                    }
                    else if ( statisticType == TSStatisticType.CHANGE_FRACTION_ABS ) {
                    	// Difference between last sample value and first sample value, fraction, absolute.
                    	if ( count > 0 ) {
                    		if ( !ts.isDataMissing(sampleArray[0]) && !ts.isDataMissing(sampleArray[count - 1]) ) {
                    			if ( sampleArray[0] != 0.0 ) {
                    				value = Math.abs((sampleArray[count - 1] - sampleArray[0])/sampleArray[0]);
                    				newts.setDataValue(date,value);
                    			}
                    		}
                    	}
                    	// Else time series will be missing by default.
                    }
                    else if ( statisticType == TSStatisticType.CHANGE_PERCENT ) {
                    	// Difference between last sample value and first sample value, percent.
                    	if ( count > 0 ) {
                    		if ( !ts.isDataMissing(sampleArray[0]) && !ts.isDataMissing(sampleArray[count - 1]) ) {
                    			if ( sampleArray[0] != 0 ) {
                    				value = 100.0*(sampleArray[count - 1] - sampleArray[0])/sampleArray[0];
                    				newts.setDataValue(date,value);
                    			}
                    		}
                    	}
                    	// Else time series will be missing by default.
                    }
                    else if ( statisticType == TSStatisticType.CHANGE_PERCENT_ABS ) {
                    	// Difference between last sample value and first sample value, percent, absolute.
                    	if ( count > 0 ) {
                    		if ( !ts.isDataMissing(sampleArray[0]) && !ts.isDataMissing(sampleArray[count - 1]) ) {
                    			if ( sampleArray[0] != 0.0 ) {
                    				value = Math.abs(100.0*(sampleArray[count - 1] - sampleArray[0])/sampleArray[0]);
                    				newts.setDataValue(date,value);
                    			}
                    		}
                    	}
                    	// Else time series will be missing by default.
                    }
                    else if ( statisticType == TSStatisticType.EXCEEDANCE_PROBABILITY ) {
                        value = ts.getDataValue(date);
                        if ( !ts.isDataMissing(value) ) {
                            // The value will also be in the array so it should exactly match an exceedance probability.
                        	// The following algorithm will interpolate if necessary but the value
                            // will be very near a calculated value.
                            newts.setDataValue(date,MathUtil.exceedanceProbability(count, sampleArray, value)*unitsMult);
                        }
                    }
                    else if ( statisticType == TSStatisticType.GEOMETRIC_MEAN ) {
                        newts.setDataValue(date,MathUtil.geometricMean(count, sampleArray));
                    }
                    else if ( statisticType == TSStatisticType.LAG1_AUTO_CORRELATION ) {
                        newts.setDataValue(date,MathUtil.lagAutoCorrelation(count, sampleArray, 1));
                    }
                    else if ( statisticType == TSStatisticType.MAX ) {
                        newts.setDataValue(date,MathUtil.max(count, sampleArray));
                    }
                    else if ( statisticType == TSStatisticType.MEAN ) {
                        newts.setDataValue(date,MathUtil.mean(count, sampleArray));
                    }
                    else if ( statisticType == TSStatisticType.MEDIAN ) {
                        newts.setDataValue(date,MathUtil.median(count, sampleArray));
                    }
                    else if ( statisticType == TSStatisticType.MIN ) {
                        newts.setDataValue(date,MathUtil.min(count, sampleArray));
                    }
                    else if ( (statisticType == TSStatisticType.NEW_MAX) ||
                    	(statisticType == TSStatisticType.NEW_MIN)
                    	) {
                    	haveNewStatisticForSample = false; // Don't yet know whether have value to set as new statistic value.
                    	String dateKey = null;
                    	if ( intervalBase == TimeInterval.DAY ) {
                    		dateKey = String.format("%02d%02d", date.getMonth(), date.getDay() );
                    	}
                    	else if ( intervalBase == TimeInterval.MONTH ) {
                    		dateKey = String.format("%02d", date.getMonth() );
                    	}
                    	// Indicate how to indicate new max:
                   		// - if unit value, set value to 1 for new max, 0 if not
                    	// - otherwise, set the value to the new maximum value
                   		boolean setUnitValue = false;  // TODO smalers 2020-03-01 Will test out and see if this logic should be the only logic
                   		// Only daily sample filter is currently supported.
                   		statisticForPeriod = statisticForPeriodByInterval.get(dateKey);
                   		if ( Double.isNaN(statisticForPeriod) ) {
                   			// Statistic for period has not been set yet so set it:
                   			// - the value will be checked below to decide if a new value is found
                   			haveNewStatisticForSample = true;
                   		}
                        // Always need to do the calculation.
                       	if ( statisticType == TSStatisticType.NEW_MAX ) {
                    	   	// Calculate the new maximum.
                       	   	statisticForSample = MathUtil.max(count, sampleArray);
                       	   	if ( statisticForSample > statisticForPeriod ) {
                       	   		haveNewStatisticForSample = true;
                       	   	}
                       	}
                       	else if ( statisticType == TSStatisticType.NEW_MIN ) {
                    	   	// Calculate the new minimum.
                       	   	statisticForSample = MathUtil.min(count, sampleArray);
                       	   	if ( statisticForSample < statisticForPeriod ) {
                       	   		haveNewStatisticForSample = true;
                       		}
                       	}
                       	if ( haveNewStatisticForSample ) {
                       		// Set the flag to the triggering value so it can be displayed later:
                       		// - set the value in the hash, currently only supported for day
                      		statisticForPeriodByInterval.put(dateKey,statisticForSample);
                       		if ( setUnitValue ) {
                       			// Set a value of 1 for time series indicating new maximum:
                       			String newValueString = String.format("%.2f",statisticForSample);
                       			newts.setDataValue(date,1.0,newValueString,-1);
                       		}
                       		else {
                       			// Set the new value as the time series value.
                       			newts.setDataValue(date,statisticForSample);
                       		}
                       	}
                       	else {
                       	   	// Not a new maximum so set to the indicator value of 0.0, no need for flag.
                       		if ( setUnitValue ) {
                       			newts.setDataValue(date,0.0);
                       		}
                       	}
                    }
                    else if ( statisticType == TSStatisticType.NONEXCEEDANCE_PROBABILITY ) {
                        value = ts.getDataValue(date);
                        if ( !ts.isDataMissing(value) ) {
                            newts.setDataValue(date,MathUtil.nonexceedanceProbability(count, sampleArray, value)*unitsMult);
                        }
                    }
                    else if ( statisticType == TSStatisticType.PLOTTING_POSITION ) {
                        value = ts.getDataValue(date);
                        if ( !ts.isDataMissing(value) ) {
                            // The value will also be in the array so it should exactly match a rank.
                            // The following algorithm will lookup the value.
                            newts.setDataValue(date,MathUtil.plottingPosition(count, sampleArray, sortOrderType,
                                distributionType, distributionParameters, value));
                        }
                    }
                    else if ( statisticType == TSStatisticType.RANK ) {
                        value = ts.getDataValue(date);
                        if ( !ts.isDataMissing(value) ) {
                            // The value will also be in the array so it should exactly match a rank.
                            // The following algorithm will lookup the value.
                            newts.setDataValue(date,MathUtil.rank(count, sampleArray, sortOrderType, value));
                        }
                    }
                    else if ( statisticType == TSStatisticType.SKEW ) {
                        newts.setDataValue(date,MathUtil.skew(count, sampleArray));
                    }
                    else if ( statisticType == TSStatisticType.STD_DEV ) {
                        newts.setDataValue(date,MathUtil.standardDeviation(count, sampleArray));
                    }
                    else if ( statisticType == TSStatisticType.TOTAL ) {
                        newts.setDataValue(date,MathUtil.sum(count, sampleArray));
                    }
                    else if ( statisticType == TSStatisticType.VARIANCE ) {
                        newts.setDataValue(date,MathUtil.variance(count, sampleArray));
                    }
                }
                catch ( Exception e ) {
                    // Should only happen in cases where there is a data issue (insufficient data in sample should
                    // just result in missing values).
                    __problems.add ( "Error computing statistic at " + date + " (" + e + ")" );
                }
            }
        }
        if ( statisticTypeForNormal != null ) {
            // Handle cases where a secondary statistic is being computed.
            // Have to process the original value (ts) and the intermediate statistic (newts)
            // to get the final output (newts2).
        	// Complexity for normal period - the initial analysis is performed on the normal period but the analysis
        	// period may not exactly align.  Because the normal period can only be specified
        	// with bracket of ALL_YEARS, can go through the initial statistic time series and find a value
        	// on the same date to use for the math - this is all handled below
        	// FIXME SAM - remove this when figured out issues.
        	//for ( DateTime d = new DateTime(newts.getDate1()); d.lessThanOrEqualTo(newts.getDate2()); d.addInterval(intervalBase,intervalMult) ) {
        	//	Message.printStatus(2, routine, "After computing normal period statistic, date=" + d + " value=" + newts.getDataValue(d));
        	//}
            date = new DateTime(analysisStart);
            end = new DateTime(analysisEnd);
            DateTime normalStart2 = null;
            DateTime normalEnd2 = null;
            if ( normalStart != null ) {
                normalStart2 = new DateTime(normalStart);
            }
            else {
                normalStart2 = new DateTime(analysisStart);
            }
            if ( normalEnd != null ) {
                normalEnd2 = new DateTime(normalEnd);
            }
            else {
                normalEnd2 = new DateTime(analysisEnd);
            }
            DateTime normalDate = new DateTime(normalStart); // To get proper precision.
            double normalValue; // The value computed as the normal
            for ( ; date.lessThanOrEqualTo( end ); date.addInterval(intervalBase, intervalMult) ) {
                value = ts.getDataValue(date);
                // Set the normal date to match the date but make sure the year is in the normal period.
                // If normal period is specified, then only AllYears for sample is allowed so all values
                // that were computed in newts in the analysis period will be the same on the interval of interest
                // (e.g., Jan 1).
                setNormalDateForAnalysisDate(normalDate,date,normalStart2,normalEnd2);
                normalValue = newts.getDataValue(normalDate);
                if ( ts.isDataMissing(value) ) {
                    // Can't compute the secondary statistic so set missing.
                    newts2.setDataValue(date,missing,"tsmissing",-1);
                    continue;
                }
                else if ( newts.isDataMissing(normalValue)) {
                    // Can't compute the secondary statistic so set missing.
                    newts2.setDataValue(date,missing,"stat0missing",-1);
                    continue;
                }
                else if ( (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEAN) ||
                    (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEDIAN) ||
                    (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MAX) ||
                    (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MIN) ) {
                    if ( normalValue == 0.0 ) {
                        // Division by zero so set to missing and set data flag.
                        newts2.setDataValue(date,missing,"input zero",-1);
                    }
                    else {
                        newts2.setDataValue(date,(value/normalValue)*100.0);
                    }
                }
                else {
                    throw new RuntimeException ( "Unable to handle statistic for normal period:  " + statisticTypeForNormal );
                }
            }
            // Reset the output time series.
            newts = newts2;
        }
        /* TODO SAM 2014-03-20 Remove this when tested out.
        if ( statisticTypeForNormal != null ) {
            // Handle cases where a secondary statistic is being computed.
            // If the analysis period is the same as the normal period then just divide the original value by
            // the calculated statistic.  If the periods are different need to allocate a new time series (was already
            // done above as newts2).
            if ( ((normalStart == null) && (normalEnd == null)) ||
                ((normalStart.equals(analysisStart) && normalEnd.equals(analysisEnd)) ) ) {
                date = new DateTime(analysisStart);
                end = new DateTime(analysisEnd);
                for ( ; date.lessThanOrEqualTo( end ); date.addInterval(intervalBase, intervalMult) ) {
                    value = ts.getDataValue(date);
                    if ( ts.isDataMissing(value) ) {
                        // Can't compute the secondary statistic so set missing.
                        newts.setDataValue(date,missing);
                        continue;
                    }
                    if ( (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEAN) ||
                        (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEDIAN) ||
                        (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MAX) ||
                        (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MIN) ) {
                        if ( newts.getDataValue(date) == 0.0 ) {
                            // Division by zero so set to missing.
                            newts.setDataValue(date,missing);
                        }
                        else {
                            newts.setDataValue(date,(value/newts.getDataValue(date))*100.0);
                        }
                    }
                }
            }
            else if ( ((normalStart != null) && (normalEnd != null)) &&
                ((!normalStart.equals(analysisStart) && (!normalEnd.equals(analysisEnd))) ) ) {
                // Need to create a new output time series because the first pass is not the final output.
                date = new DateTime(analysisStart);
                end = new DateTime(analysisEnd);
                DateTime normalDate = new DateTime(normalStart); // To get proper precision.
                double normalValue; // The value computed as the normal
                for ( ; date.lessThanOrEqualTo( end ); date.addInterval(intervalBase, intervalMult) ) {
                    value = ts.getDataValue(date);
                    // Set the normal date to match the date but make sure the year is in the normal period.
                    // If normal period is specified, then only AllYears for sample is allowed so all values
                    // that were computed in newts in the analysis period will be the same on the interval of interest
                    // (e.g., Jan 1).
                    setNormalDateForAnalysisDate(normalDate,date,normalStart,normalEnd);
                    normalValue = newts.getDataValue(normalDate);
                    if ( ts.isDataMissing(value) ) {
                        // Can't compute the secondary statistic so set missing.
                        newts2.setDataValue(date,missing,"tsmissing",-1);
                        continue;
                    }
                    else if ( newts.isDataMissing(normalValue)) {
                        // Can't compute the secondary statistic so set missing.
                        newts2.setDataValue(date,missing,"stat0missing",-1);
                        continue;
                    }
                    else if ( (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEAN) ||
                        (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEDIAN) ||
                        (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MAX) ||
                        (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MIN) ) {
                        if ( normalValue == 0.0 ) {
                            // Division by zero so set to missing and set data flag.
                            newts2.setDataValue(date,missing,"input zero",-1);
                        }
                        else {
                            newts2.setDataValue(date,(value/normalValue)*100.0);
                        }
                    }
                    else {
                        throw new RuntimeException ( "Unable to handle statistic for normal period:  " + statisticTypeForNormal );
                    }
                }
                // Reset the output time series.
                newts = newts2;
            }
        }
        */
    
        // Add to the genesis.
    
        newts.addToGenesis ( "Created " + genesis + " running " + statString + " time series from original data" );
        newts.setDescription ( newts.getDescription() + ", " + genesis + " run stat" );
    }
    return newts;
}

/**
Set the number of missing values allowed in the sample.
*/
private void setAllowMissingCount ( int allowMissingCount ) {
    __allowMissingCount = allowMissingCount;
}

/**
Set the analysis period end.
*/
private void setAnalysisEnd ( DateTime analysisEnd ) {
    __analysisEnd = analysisEnd;
}

/**
Set the analysis period start.
*/
private void setAnalysisStart ( DateTime analysisStart ) {
    __analysisStart = analysisStart;
}

/**
Set the distribution type.
*/
private void setDistributionType ( DistributionType distribution ) {
    __distribution = distribution;
}

/**
Set the distribution parameters.
*/
private void setDistributionParameters ( Hashtable<String,String> distributionParameters ) {
    __distributionParameters = distributionParameters;
}

/**
Set the minimum sample size in order to calculate the statistic.
*/
private void setMinimumSampleSize ( int minimumSampleSize ) {
    __minimumSampleSize = minimumSampleSize;
}

/**
Set the N for N-Year or bracket for other running statistic types.
*/
private void setN ( int n ) {
    __n = n;
}

/**
Set the monthly N for N-Year or bracket for other running statistic types.
*/
private void setNByMonth ( Integer [] nByMonth ) {
    __nByMonth = nByMonth;
}

/**
Set the custom monthly N for N-Year or bracket for other running statistic types.
*/
private void setNCustomByMonth ( Integer [][] nCustomByMonth ) {
    __nCustomByMonth = nCustomByMonth;
}

/**
Set the date in the normal period for an analysis date.  The normal date must be consistent with the analysis date,
with everything the same and the year being aligned so that leap year (or not) overlay.  This ensures that the
day from the normal period will be correct when requested for the analysis date.  This method is called when
computing final output using the normal period statistics.
@param normalDate the date from the normal period to be adjusted
@param analysisDate the date from the analysis period from iteration
@normalStart the start of the normal period
@normalEnd the end of the normal period
*/
private void setNormalDateForAnalysisDate(DateTime normalDate, DateTime analysisDate, DateTime normalStart, DateTime normalEnd)
{   // Calculate how many years AFTER a leap year the analysisDate is.
    int ay = analysisDate.getYear();
    boolean isLeap = TimeUtil.isLeapYear(ay);
    // First set the date to the current analysis date.
    normalDate.setDate(analysisDate);
    normalDate.setYear(normalStart.getYear());
    if ( normalDate.lessThan(normalStart) ) {
        // Need to go a year forward due to how the first month/day occur to be in the normal period.
        normalDate.addYear(1);
    }
    if ( isLeap ) {
        // Move forward until within the normal period until a leap year is matched.
        for ( int i = 0; i < 4; i++ ) {
            if ( TimeUtil.isLeapYear(normalDate.getYear()) ) {
                break;
            }
            normalDate.addYear(1);
        }
    }
    if ( normalDate.greaterThan(normalEnd) ) {
        // This should not happen but check to make sure.
        throw new RuntimeException ( "Unable to determine date in normal period (" + normalStart + " - " +
            normalEnd + ") starting with analysis date " + analysisDate + " - normal period too short?" );
    }
}

/**
Set the normal period end.
*/
private void setNormalEnd ( DateTime normalEnd ) {
    __normalEnd = normalEnd;
}

/**
Set the normal period start.
*/
private void setNormalStart ( DateTime normalStart ) {
    __normalStart = normalStart;
}

/**
Set the output period end.
*/
private void setOutputEnd ( DateTime outputEnd ) {
    __outputEnd = outputEnd;
}

/**
Set the output period start.
*/
private void setOutputStart ( DateTime outputStart ) {
    __outputStart = outputStart;
}

/**
Set the units for probability statistics.
*/
private void setProbabilityUnits ( String probabilityUnits ) {
    __probabilityUnits = probabilityUnits;
}

/**
Set the method by which the data sample is determined.
*/
private void setSampleType ( RunningAverageType runningAverageType ) {
    this.__sampleType = runningAverageType;
}

/**
Set the sort order.
*/
private void setSortOrderType ( SortOrderType sortOrderType ) {
    __sortOrderType = sortOrderType;
}

/**
Set the statistic.
*/
private void setStatisticType ( TSStatisticType statistic ) {
    __statistic = statistic;
}

/**
Set the time series to process.
*/
private void setTS ( TS ts ) {
    __ts = ts;
}

}